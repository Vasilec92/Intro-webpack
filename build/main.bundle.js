/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style/style.css":
/*!*******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style/style.css ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"body {\\n  background-color: antiquewhite;\\n}\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://intro-webpack/./src/style/style.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var _i = 0; _i < this.length; _i++) {\n        var id = this[_i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i2 = 0; _i2 < modules.length; _i2++) {\n      var item = [].concat(modules[_i2]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://intro-webpack/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://intro-webpack/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/style/style.css":
/*!*****************************!*\
  !*** ./src/style/style.css ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./style.css */ \"./node_modules/css-loader/dist/cjs.js!./src/style/style.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://intro-webpack/./src/style/style.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://intro-webpack/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://intro-webpack/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://intro-webpack/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://intro-webpack/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://intro-webpack/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://intro-webpack/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/js/datecalc.js":
/*!****************************!*\
  !*** ./src/js/datecalc.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"diffDates\": () => (/* binding */ diffDates),\n/* harmony export */   \"diffToHtml\": () => (/* binding */ diffToHtml)\n/* harmony export */ });\n/* harmony import */ var _luxon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./luxon.js */ \"./src/js/luxon.js\");\n // 1\n\nfunction diffDates(firstDate, secondDate) {\n  firstDate = _luxon_js__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(firstDate);\n  secondDate = _luxon_js__WEBPACK_IMPORTED_MODULE_0__.DateTime.fromISO(secondDate);\n\n  if (firstDate > secondDate)\n    secondDate = [firstDate, (firstDate = secondDate)][0]; // 2\n\n  return secondDate.diff(firstDate, [\"years\", \"months\", \"days\"]).toObject();\n}\n\n// 3\nconst diffToHtml = (diff) => `\n    <span> \n        ${diff.years ? \"Лет: \" + diff.years : \"\"} \n        ${diff.months ? \"Месяцев: \" + diff.months : \"\"} \n        ${diff.days ? \"Дней: \" + diff.days : \"\"}\n    </span>\n`;\n\n\n//# sourceURL=webpack://intro-webpack/./src/js/datecalc.js?");

/***/ }),

/***/ "./src/js/dates.js":
/*!*************************!*\
  !*** ./src/js/dates.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handleCalcDates)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/js/utils.js\");\n/* harmony import */ var _datecalc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./datecalc.js */ \"./src/js/datecalc.js\");\n // 2\n // 1\nconst dateCalcResult = document.getElementById(\"datecalc__result\");\nfunction handleCalcDates(event) {\n  dateCalcResult.innerHTML = \"\";\n  event.preventDefault();\n\n  let { firstDate, secondDate } = event.target.elements;\n  (firstDate = firstDate.value), (secondDate = secondDate.value);\n\n  if (firstDate && secondDate) {\n    const diff = (0,_datecalc_js__WEBPACK_IMPORTED_MODULE_1__.diffDates)(firstDate, secondDate); // 3\n    dateCalcResult.innerHTML = (0,_datecalc_js__WEBPACK_IMPORTED_MODULE_1__.diffToHtml)(diff); // 4\n  } else\n    dateCalcResult.innerHTML = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.formatError)(\n      \"Для расчета промежутка необходимо заполнить оба поля\"\n    ); // 5\n}\n\n\n//# sourceURL=webpack://intro-webpack/./src/js/dates.js?");

/***/ }),

/***/ "./src/js/howler.js":
/*!**************************!*\
  !*** ./src/js/howler.js ***!
  \**************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n *  howler.js v2.2.3\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create the global controller. All contained methods and properties apply\n   * to all sounds that are currently playing or will be in the future.\n   */\n  var HowlerGlobal = function() {\n    this.init();\n  };\n  HowlerGlobal.prototype = {\n    /**\n     * Initialize the global Howler object.\n     * @return {Howler}\n     */\n    init: function() {\n      var self = this || Howler;\n\n      // Create a global ID counter.\n      self._counter = 1000;\n\n      // Pool of unlocked HTML5 Audio objects.\n      self._html5AudioPool = [];\n      self.html5PoolSize = 10;\n\n      // Internal properties.\n      self._codecs = {};\n      self._howls = [];\n      self._muted = false;\n      self._volume = 1;\n      self._canPlayEvent = 'canplaythrough';\n      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;\n\n      // Public properties.\n      self.masterGain = null;\n      self.noAudio = false;\n      self.usingWebAudio = true;\n      self.autoSuspend = true;\n      self.ctx = null;\n\n      // Set to false to disable the auto audio unlocker.\n      self.autoUnlock = true;\n\n      // Setup the various state values for global tracking.\n      self._setup();\n\n      return self;\n    },\n\n    /**\n     * Get/set the global volume for all sounds.\n     * @param  {Float} vol Volume from 0.0 to 1.0.\n     * @return {Howler/Float}     Returns self or current volume.\n     */\n    volume: function(vol) {\n      var self = this || Howler;\n      vol = parseFloat(vol);\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        self._volume = vol;\n\n        // Don't update any of the nodes if we are muted.\n        if (self._muted) {\n          return self;\n        }\n\n        // When using Web Audio, we just need to adjust the master gain.\n        if (self.usingWebAudio) {\n          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n        }\n\n        // Loop through and change volume for all HTML5 audio nodes.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and change the volumes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node) {\n                sound._node.volume = sound._volume * vol;\n              }\n            }\n          }\n        }\n\n        return self;\n      }\n\n      return self._volume;\n    },\n\n    /**\n     * Handle muting and unmuting globally.\n     * @param  {Boolean} muted Is muted or not.\n     */\n    mute: function(muted) {\n      var self = this || Howler;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      self._muted = muted;\n\n      // With Web Audio, we just need to mute the master gain.\n      if (self.usingWebAudio) {\n        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);\n      }\n\n      // Loop through and mute all HTML5 Audio nodes.\n      for (var i=0; i<self._howls.length; i++) {\n        if (!self._howls[i]._webAudio) {\n          // Get all of the sounds in this Howl group.\n          var ids = self._howls[i]._getSoundIds();\n\n          // Loop through all sounds and mark the audio node as muted.\n          for (var j=0; j<ids.length; j++) {\n            var sound = self._howls[i]._soundById(ids[j]);\n\n            if (sound && sound._node) {\n              sound._node.muted = (muted) ? true : sound._muted;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Handle stopping all sounds globally.\n     */\n    stop: function() {\n      var self = this || Howler;\n\n      // Loop through all Howls and stop them.\n      for (var i=0; i<self._howls.length; i++) {\n        self._howls[i].stop();\n      }\n\n      return self;\n    },\n\n    /**\n     * Unload and destroy all currently loaded Howl objects.\n     * @return {Howler}\n     */\n    unload: function() {\n      var self = this || Howler;\n\n      for (var i=self._howls.length-1; i>=0; i--) {\n        self._howls[i].unload();\n      }\n\n      // Create a new AudioContext to make sure it is fully reset.\n      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {\n        self.ctx.close();\n        self.ctx = null;\n        setupAudioContext();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for codec support of specific extension.\n     * @param  {String} ext Audio file extention.\n     * @return {Boolean}\n     */\n    codecs: function(ext) {\n      return (this || Howler)._codecs[ext.replace(/^x-/, '')];\n    },\n\n    /**\n     * Setup various state values for global tracking.\n     * @return {Howler}\n     */\n    _setup: function() {\n      var self = this || Howler;\n\n      // Keeps track of the suspend/resume state of the AudioContext.\n      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';\n\n      // Automatically begin the 30-second suspend process\n      self._autoSuspend();\n\n      // Check if audio is available.\n      if (!self.usingWebAudio) {\n        // No audio is available on this system if noAudio is set to true.\n        if (typeof Audio !== 'undefined') {\n          try {\n            var test = new Audio();\n\n            // Check if the canplaythrough event is available.\n            if (typeof test.oncanplaythrough === 'undefined') {\n              self._canPlayEvent = 'canplay';\n            }\n          } catch(e) {\n            self.noAudio = true;\n          }\n        } else {\n          self.noAudio = true;\n        }\n      }\n\n      // Test to make sure audio isn't disabled in Internet Explorer.\n      try {\n        var test = new Audio();\n        if (test.muted) {\n          self.noAudio = true;\n        }\n      } catch (e) {}\n\n      // Check for supported codecs.\n      if (!self.noAudio) {\n        self._setupCodecs();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for browser support for various codecs and cache the results.\n     * @return {Howler}\n     */\n    _setupCodecs: function() {\n      var self = this || Howler;\n      var audioTest = null;\n\n      // Must wrap in a try/catch because IE11 in server mode throws an error.\n      try {\n        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;\n      } catch (err) {\n        return self;\n      }\n\n      if (!audioTest || typeof audioTest.canPlayType !== 'function') {\n        return self;\n      }\n\n      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');\n\n      // Opera version <33 has mixed MP3 support, so we need to check for and block it.\n      var ua = self._navigator ? self._navigator.userAgent : '';\n      var checkOpera = ua.match(/OPR\\/([0-6].)/g);\n      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);\n      var checkSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;\n      var safariVersion = ua.match(/Version\\/(.*?) /);\n      var isOldSafari = (checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15);\n\n      self._codecs = {\n        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),\n        mpeg: !!mpegTest,\n        opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, ''),\n        ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        wav: !!(audioTest.canPlayType('audio/wav; codecs=\"1\"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),\n        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),\n        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),\n        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n        webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n        dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, ''),\n        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')\n      };\n\n      return self;\n    },\n\n    /**\n     * Some browsers/devices will only allow audio to be played after a user interaction.\n     * Attempt to automatically unlock audio on the first user interaction.\n     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/\n     * @return {Howler}\n     */\n    _unlockAudio: function() {\n      var self = this || Howler;\n\n      // Only run this if Web Audio is supported and it hasn't already been unlocked.\n      if (self._audioUnlocked || !self.ctx) {\n        return;\n      }\n\n      self._audioUnlocked = false;\n      self.autoUnlock = false;\n\n      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.\n      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.\n      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.\n      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {\n        self._mobileUnloaded = true;\n        self.unload();\n      }\n\n      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:\n      // http://stackoverflow.com/questions/24119684\n      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);\n\n      // Call this method on touch start to create and play a buffer,\n      // then check if the audio actually played to determine if\n      // audio has now been unlocked on iOS, Android, etc.\n      var unlock = function(e) {\n        // Create a pool of unlocked HTML5 Audio objects that can\n        // be used for playing sounds without user interaction. HTML5\n        // Audio objects must be individually unlocked, as opposed\n        // to the WebAudio API which only needs a single activation.\n        // This must occur before WebAudio setup or the source.onended\n        // event will not fire.\n        while (self._html5AudioPool.length < self.html5PoolSize) {\n          try {\n            var audioNode = new Audio();\n\n            // Mark this Audio object as unlocked to ensure it can get returned\n            // to the unlocked pool when released.\n            audioNode._unlocked = true;\n\n            // Add the audio node to the pool.\n            self._releaseHtml5Audio(audioNode);\n          } catch (e) {\n            self.noAudio = true;\n            break;\n          }\n        }\n\n        // Loop through any assigned audio nodes and unlock them.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and unlock the audio nodes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node && !sound._node._unlocked) {\n                sound._node._unlocked = true;\n                sound._node.load();\n              }\n            }\n          }\n        }\n\n        // Fix Android can not play in suspend state.\n        self._autoResume();\n\n        // Create an empty buffer.\n        var source = self.ctx.createBufferSource();\n        source.buffer = self._scratchBuffer;\n        source.connect(self.ctx.destination);\n\n        // Play the empty buffer.\n        if (typeof source.start === 'undefined') {\n          source.noteOn(0);\n        } else {\n          source.start(0);\n        }\n\n        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\n        if (typeof self.ctx.resume === 'function') {\n          self.ctx.resume();\n        }\n\n        // Setup a timeout to check that we are unlocked on the next event loop.\n        source.onended = function() {\n          source.disconnect(0);\n\n          // Update the unlocked state and prevent this check from happening again.\n          self._audioUnlocked = true;\n\n          // Remove the touch start listener.\n          document.removeEventListener('touchstart', unlock, true);\n          document.removeEventListener('touchend', unlock, true);\n          document.removeEventListener('click', unlock, true);\n          document.removeEventListener('keydown', unlock, true);\n\n          // Let all sounds know that audio has been unlocked.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('unlock');\n          }\n        };\n      };\n\n      // Setup a touch start listener to attempt an unlock in.\n      document.addEventListener('touchstart', unlock, true);\n      document.addEventListener('touchend', unlock, true);\n      document.addEventListener('click', unlock, true);\n      document.addEventListener('keydown', unlock, true);\n\n      return self;\n    },\n\n    /**\n     * Get an unlocked HTML5 Audio object from the pool. If none are left,\n     * return a new Audio object and throw a warning.\n     * @return {Audio} HTML5 Audio object.\n     */\n    _obtainHtml5Audio: function() {\n      var self = this || Howler;\n\n      // Return the next object from the pool if one exists.\n      if (self._html5AudioPool.length) {\n        return self._html5AudioPool.pop();\n      }\n\n      //.Check if the audio is locked and throw a warning.\n      var testPlay = new Audio().play();\n      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {\n        testPlay.catch(function() {\n          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');\n        });\n      }\n\n      return new Audio();\n    },\n\n    /**\n     * Return an activated HTML5 Audio object to the pool.\n     * @return {Howler}\n     */\n    _releaseHtml5Audio: function(audio) {\n      var self = this || Howler;\n\n      // Don't add audio to the pool if we don't know if it has been unlocked.\n      if (audio._unlocked) {\n        self._html5AudioPool.push(audio);\n      }\n\n      return self;\n    },\n\n    /**\n     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.\n     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.\n     * @return {Howler}\n     */\n    _autoSuspend: function() {\n      var self = this;\n\n      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      // Check if any sounds are playing.\n      for (var i=0; i<self._howls.length; i++) {\n        if (self._howls[i]._webAudio) {\n          for (var j=0; j<self._howls[i]._sounds.length; j++) {\n            if (!self._howls[i]._sounds[j]._paused) {\n              return self;\n            }\n          }\n        }\n      }\n\n      if (self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n      }\n\n      // If no sound has played after 30 seconds, suspend the context.\n      self._suspendTimer = setTimeout(function() {\n        if (!self.autoSuspend) {\n          return;\n        }\n\n        self._suspendTimer = null;\n        self.state = 'suspending';\n\n        // Handle updating the state of the audio context after suspending.\n        var handleSuspension = function() {\n          self.state = 'suspended';\n\n          if (self._resumeAfterSuspend) {\n            delete self._resumeAfterSuspend;\n            self._autoResume();\n          }\n        };\n\n        // Either the state gets suspended or it is interrupted.\n        // Either way, we need to update the state to suspended.\n        self.ctx.suspend().then(handleSuspension, handleSuspension);\n      }, 30000);\n\n      return self;\n    },\n\n    /**\n     * Automatically resume the Web Audio AudioContext when a new sound is played.\n     * @return {Howler}\n     */\n    _autoResume: function() {\n      var self = this;\n\n      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n        self._suspendTimer = null;\n      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {\n        self.ctx.resume().then(function() {\n          self.state = 'running';\n\n          // Emit to all Howls that the audio has resumed.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('resume');\n          }\n        });\n\n        if (self._suspendTimer) {\n          clearTimeout(self._suspendTimer);\n          self._suspendTimer = null;\n        }\n      } else if (self.state === 'suspending') {\n        self._resumeAfterSuspend = true;\n      }\n\n      return self;\n    }\n  };\n\n  // Setup the global audio controller.\n  var Howler = new HowlerGlobal();\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create an audio group controller.\n   * @param {Object} o Passed in properties for this group.\n   */\n  var Howl = function(o) {\n    var self = this;\n\n    // Throw an error if no source is provided.\n    if (!o.src || o.src.length === 0) {\n      console.error('An array of source files must be passed with any new Howl.');\n      return;\n    }\n\n    self.init(o);\n  };\n  Howl.prototype = {\n    /**\n     * Initialize a new Howl group object.\n     * @param  {Object} o Passed in properties for this group.\n     * @return {Howl}\n     */\n    init: function(o) {\n      var self = this;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!Howler.ctx) {\n        setupAudioContext();\n      }\n\n      // Setup user-defined default properties.\n      self._autoplay = o.autoplay || false;\n      self._format = (typeof o.format !== 'string') ? o.format : [o.format];\n      self._html5 = o.html5 || false;\n      self._muted = o.mute || false;\n      self._loop = o.loop || false;\n      self._pool = o.pool || 5;\n      self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;\n      self._rate = o.rate || 1;\n      self._sprite = o.sprite || {};\n      self._src = (typeof o.src !== 'string') ? o.src : [o.src];\n      self._volume = o.volume !== undefined ? o.volume : 1;\n      self._xhr = {\n        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',\n        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,\n        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,\n      };\n\n      // Setup all other default properties.\n      self._duration = 0;\n      self._state = 'unloaded';\n      self._sounds = [];\n      self._endTimers = {};\n      self._queue = [];\n      self._playLock = false;\n\n      // Setup event listeners.\n      self._onend = o.onend ? [{fn: o.onend}] : [];\n      self._onfade = o.onfade ? [{fn: o.onfade}] : [];\n      self._onload = o.onload ? [{fn: o.onload}] : [];\n      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];\n      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];\n      self._onpause = o.onpause ? [{fn: o.onpause}] : [];\n      self._onplay = o.onplay ? [{fn: o.onplay}] : [];\n      self._onstop = o.onstop ? [{fn: o.onstop}] : [];\n      self._onmute = o.onmute ? [{fn: o.onmute}] : [];\n      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];\n      self._onrate = o.onrate ? [{fn: o.onrate}] : [];\n      self._onseek = o.onseek ? [{fn: o.onseek}] : [];\n      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];\n      self._onresume = [];\n\n      // Web Audio or HTML5 Audio?\n      self._webAudio = Howler.usingWebAudio && !self._html5;\n\n      // Automatically try to enable audio.\n      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {\n        Howler._unlockAudio();\n      }\n\n      // Keep track of this Howl group in the global controller.\n      Howler._howls.push(self);\n\n      // If they selected autoplay, add a play event to the load queue.\n      if (self._autoplay) {\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play();\n          }\n        });\n      }\n\n      // Load the source file unless otherwise specified.\n      if (self._preload && self._preload !== 'none') {\n        self.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Load the audio file.\n     * @return {Howler}\n     */\n    load: function() {\n      var self = this;\n      var url = null;\n\n      // If no audio is available, quit immediately.\n      if (Howler.noAudio) {\n        self._emit('loaderror', null, 'No audio support.');\n        return;\n      }\n\n      // Make sure our source is in an array.\n      if (typeof self._src === 'string') {\n        self._src = [self._src];\n      }\n\n      // Loop through the sources and pick the first one that is compatible.\n      for (var i=0; i<self._src.length; i++) {\n        var ext, str;\n\n        if (self._format && self._format[i]) {\n          // If an extension was specified, use that instead.\n          ext = self._format[i];\n        } else {\n          // Make sure the source is a string.\n          str = self._src[i];\n          if (typeof str !== 'string') {\n            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');\n            continue;\n          }\n\n          // Extract the file extension from the URL or base64 data URI.\n          ext = /^data:audio\\/([^;,]+);/i.exec(str);\n          if (!ext) {\n            ext = /\\.([^.]+)$/.exec(str.split('?', 1)[0]);\n          }\n\n          if (ext) {\n            ext = ext[1].toLowerCase();\n          }\n        }\n\n        // Log a warning if no extension was found.\n        if (!ext) {\n          console.warn('No file extension was found. Consider using the \"format\" property or specify an extension.');\n        }\n\n        // Check if this extension is available.\n        if (ext && Howler.codecs(ext)) {\n          url = self._src[i];\n          break;\n        }\n      }\n\n      if (!url) {\n        self._emit('loaderror', null, 'No codec support for selected audio sources.');\n        return;\n      }\n\n      self._src = url;\n      self._state = 'loading';\n\n      // If the hosting page is HTTPS and the source isn't,\n      // drop down to HTML5 Audio to avoid Mixed Content errors.\n      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {\n        self._html5 = true;\n        self._webAudio = false;\n      }\n\n      // Create a new sound object and add it to the pool.\n      new Sound(self);\n\n      // Load and decode the audio data for playback.\n      if (self._webAudio) {\n        loadBuffer(self);\n      }\n\n      return self;\n    },\n\n    /**\n     * Play a sound or resume previous playback.\n     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Number}          Sound ID.\n     */\n    play: function(sprite, internal) {\n      var self = this;\n      var id = null;\n\n      // Determine if a sprite, sound id or nothing was passed\n      if (typeof sprite === 'number') {\n        id = sprite;\n        sprite = null;\n      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {\n        // If the passed sprite doesn't exist, do nothing.\n        return null;\n      } else if (typeof sprite === 'undefined') {\n        // Use the default sound sprite (plays the full audio length).\n        sprite = '__default';\n\n        // Check if there is a single paused sound that isn't ended.\n        // If there is, play that sound. If not, continue as usual.\n        if (!self._playLock) {\n          var num = 0;\n          for (var i=0; i<self._sounds.length; i++) {\n            if (self._sounds[i]._paused && !self._sounds[i]._ended) {\n              num++;\n              id = self._sounds[i]._id;\n            }\n          }\n\n          if (num === 1) {\n            sprite = null;\n          } else {\n            id = null;\n          }\n        }\n      }\n\n      // Get the selected node, or get one from the pool.\n      var sound = id ? self._soundById(id) : self._inactiveSound();\n\n      // If the sound doesn't exist, do nothing.\n      if (!sound) {\n        return null;\n      }\n\n      // Select the sprite definition.\n      if (id && !sprite) {\n        sprite = sound._sprite || '__default';\n      }\n\n      // If the sound hasn't loaded, we must wait to get the audio's duration.\n      // We also need to wait to make sure we don't run into race conditions with\n      // the order of function calls.\n      if (self._state !== 'loaded') {\n        // Set the sprite value on this sound.\n        sound._sprite = sprite;\n\n        // Mark this sound as not ended in case another sound is played before this one loads.\n        sound._ended = false;\n\n        // Add the sound to the queue to be played on load.\n        var soundId = sound._id;\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play(soundId);\n          }\n        });\n\n        return soundId;\n      }\n\n      // Don't play the sound if an id was passed and it is already playing.\n      if (id && !sound._paused) {\n        // Trigger the play event, in order to keep iterating through queue.\n        if (!internal) {\n          self._loadQueue('play');\n        }\n\n        return sound._id;\n      }\n\n      // Make sure the AudioContext isn't suspended, and resume it if it is.\n      if (self._webAudio) {\n        Howler._autoResume();\n      }\n\n      // Determine how long to play for and where to start playing.\n      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);\n      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);\n      var timeout = (duration * 1000) / Math.abs(sound._rate);\n      var start = self._sprite[sprite][0] / 1000;\n      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;\n      sound._sprite = sprite;\n\n      // Mark the sound as ended instantly so that this async playback\n      // doesn't get grabbed by another call to play while this one waits to start.\n      sound._ended = false;\n\n      // Update the parameters of the sound.\n      var setParams = function() {\n        sound._paused = false;\n        sound._seek = seek;\n        sound._start = start;\n        sound._stop = stop;\n        sound._loop = !!(sound._loop || self._sprite[sprite][2]);\n      };\n\n      // End the sound instantly if seek is at the end.\n      if (seek >= stop) {\n        self._ended(sound);\n        return;\n      }\n\n      // Begin the actual playback.\n      var node = sound._node;\n      if (self._webAudio) {\n        // Fire this when the sound is ready to play to begin Web Audio playback.\n        var playWebAudio = function() {\n          self._playLock = false;\n          setParams();\n          self._refreshBuffer(sound);\n\n          // Setup the playback params.\n          var vol = (sound._muted || self._muted) ? 0 : sound._volume;\n          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n          sound._playStart = Howler.ctx.currentTime;\n\n          // Play the sound using the supported method.\n          if (typeof node.bufferSource.start === 'undefined') {\n            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);\n          } else {\n            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);\n          }\n\n          // Start a new timer if none is present.\n          if (timeout !== Infinity) {\n            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n          }\n\n          if (!internal) {\n            setTimeout(function() {\n              self._emit('play', sound._id);\n              self._loadQueue();\n            }, 0);\n          }\n        };\n\n        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {\n          playWebAudio();\n        } else {\n          self._playLock = true;\n\n          // Wait for the audio context to resume before playing.\n          self.once('resume', playWebAudio);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      } else {\n        // Fire this when the sound is ready to play to begin HTML5 Audio playback.\n        var playHtml5 = function() {\n          node.currentTime = seek;\n          node.muted = sound._muted || self._muted || Howler._muted || node.muted;\n          node.volume = sound._volume * Howler.volume();\n          node.playbackRate = sound._rate;\n\n          // Some browsers will throw an error if this is called without user interaction.\n          try {\n            var play = node.play();\n\n            // Support older browsers that don't support promises, and thus don't have this issue.\n            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {\n              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().\n              self._playLock = true;\n\n              // Set param values immediately.\n              setParams();\n\n              // Releases the lock and executes queued actions.\n              play\n                .then(function() {\n                  self._playLock = false;\n                  node._unlocked = true;\n                  if (!internal) {\n                    self._emit('play', sound._id);\n                  } else {\n                    self._loadQueue();\n                  }\n                })\n                .catch(function() {\n                  self._playLock = false;\n                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +\n                    'on mobile devices and Chrome where playback was not within a user interaction.');\n\n                  // Reset the ended and paused values.\n                  sound._ended = true;\n                  sound._paused = true;\n                });\n            } else if (!internal) {\n              self._playLock = false;\n              setParams();\n              self._emit('play', sound._id);\n            }\n\n            // Setting rate before playing won't work in IE, so we set it again here.\n            node.playbackRate = sound._rate;\n\n            // If the node is still paused, then we can assume there was a playback issue.\n            if (node.paused) {\n              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +\n                'on mobile devices and Chrome where playback was not within a user interaction.');\n              return;\n            }\n\n            // Setup the end timer on sprites or listen for the ended event.\n            if (sprite !== '__default' || sound._loop) {\n              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n            } else {\n              self._endTimers[sound._id] = function() {\n                // Fire ended on this audio node.\n                self._ended(sound);\n\n                // Clear this listener.\n                node.removeEventListener('ended', self._endTimers[sound._id], false);\n              };\n              node.addEventListener('ended', self._endTimers[sound._id], false);\n            }\n          } catch (err) {\n            self._emit('playerror', sound._id, err);\n          }\n        };\n\n        // If this is streaming audio, make sure the src is set and load again.\n        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {\n          node.src = self._src;\n          node.load();\n        }\n\n        // Play immediately if ready, or wait for the 'canplaythrough'e vent.\n        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);\n        if (node.readyState >= 3 || loadedNoReadyState) {\n          playHtml5();\n        } else {\n          self._playLock = true;\n          self._state = 'loading';\n\n          var listener = function() {\n            self._state = 'loaded';\n            \n            // Begin playback.\n            playHtml5();\n\n            // Clear this listener.\n            node.removeEventListener(Howler._canPlayEvent, listener, false);\n          };\n          node.addEventListener(Howler._canPlayEvent, listener, false);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      }\n\n      return sound._id;\n    },\n\n    /**\n     * Pause playback and save current position.\n     * @param  {Number} id The sound ID (empty to pause all in group).\n     * @return {Howl}\n     */\n    pause: function(id) {\n      var self = this;\n\n      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'pause',\n          action: function() {\n            self.pause(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be paused.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound && !sound._paused) {\n          // Reset the seek position.\n          sound._seek = self.seek(ids[i]);\n          sound._rateSeek = 0;\n          sound._paused = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound has been created.\n              if (!sound._node.bufferSource) {\n                continue;\n              }\n\n              if (typeof sound._node.bufferSource.stop === 'undefined') {\n                sound._node.bufferSource.noteOff(0);\n              } else {\n                sound._node.bufferSource.stop(0);\n              }\n\n              // Clean up the buffer source.\n              self._cleanBuffer(sound._node);\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.pause();\n            }\n          }\n        }\n\n        // Fire the pause event, unless `true` is passed as the 2nd argument.\n        if (!arguments[1]) {\n          self._emit('pause', sound ? sound._id : null);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Stop playback and reset to start.\n     * @param  {Number} id The sound ID (empty to stop all in group).\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Howl}\n     */\n    stop: function(id, internal) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to stop when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'stop',\n          action: function() {\n            self.stop(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be stopped.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          // Reset the seek position.\n          sound._seek = sound._start || 0;\n          sound._rateSeek = 0;\n          sound._paused = true;\n          sound._ended = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound's AudioBufferSourceNode has been created.\n              if (sound._node.bufferSource) {\n                if (typeof sound._node.bufferSource.stop === 'undefined') {\n                  sound._node.bufferSource.noteOff(0);\n                } else {\n                  sound._node.bufferSource.stop(0);\n                }\n\n                // Clean up the buffer source.\n                self._cleanBuffer(sound._node);\n              }\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.currentTime = sound._start || 0;\n              sound._node.pause();\n\n              // If this is a live stream, stop download once the audio is stopped.\n              if (sound._node.duration === Infinity) {\n                self._clearSound(sound._node);\n              }\n            }\n          }\n\n          if (!internal) {\n            self._emit('stop', sound._id);\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Mute/unmute a single sound or all sounds in this Howl group.\n     * @param  {Boolean} muted Set to true to mute and false to unmute.\n     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).\n     * @return {Howl}\n     */\n    mute: function(muted, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to mute when capable.\n      if (self._state !== 'loaded'|| self._playLock) {\n        self._queue.push({\n          event: 'mute',\n          action: function() {\n            self.mute(muted, id);\n          }\n        });\n\n        return self;\n      }\n\n      // If applying mute/unmute to all sounds, update the group's value.\n      if (typeof id === 'undefined') {\n        if (typeof muted === 'boolean') {\n          self._muted = muted;\n        } else {\n          return self._muted;\n        }\n      }\n\n      // If no id is passed, get all ID's to be muted.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._muted = muted;\n\n          // Cancel active fade and set the volume to the end value.\n          if (sound._interval) {\n            self._stopFade(sound._id);\n          }\n\n          if (self._webAudio && sound._node) {\n            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);\n          } else if (sound._node) {\n            sound._node.muted = Howler._muted ? true : muted;\n          }\n\n          self._emit('mute', sound._id);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.\n     *   volume() -> Returns the group's volume value.\n     *   volume(id) -> Returns the sound id's current volume.\n     *   volume(vol) -> Sets the volume of all sounds in this Howl group.\n     *   volume(vol, id) -> Sets the volume of passed sound id.\n     * @return {Howl/Number} Returns self or current volume.\n     */\n    volume: function() {\n      var self = this;\n      var args = arguments;\n      var vol, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // Return the value of the groups' volume.\n        return self._volume;\n      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {\n        // First check if this is an ID, and if not, assume it is a new volume.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          vol = parseFloat(args[0]);\n        }\n      } else if (args.length >= 2) {\n        vol = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the volume or return the current volume.\n      var sound;\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        // If the sound hasn't loaded, add it to the load queue to change volume when capable.\n        if (self._state !== 'loaded'|| self._playLock) {\n          self._queue.push({\n            event: 'volume',\n            action: function() {\n              self.volume.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group volume.\n        if (typeof id === 'undefined') {\n          self._volume = vol;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            sound._volume = vol;\n\n            // Stop currently running fades.\n            if (!args[2]) {\n              self._stopFade(id[i]);\n            }\n\n            if (self._webAudio && sound._node && !sound._muted) {\n              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n            } else if (sound._node && !sound._muted) {\n              sound._node.volume = vol * Howler.volume();\n            }\n\n            self._emit('volume', sound._id);\n          }\n        }\n      } else {\n        sound = id ? self._soundById(id) : self._sounds[0];\n        return sound ? sound._volume : 0;\n      }\n\n      return self;\n    },\n\n    /**\n     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id (omit to fade all sounds).\n     * @return {Howl}\n     */\n    fade: function(from, to, len, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to fade when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'fade',\n          action: function() {\n            self.fade(from, to, len, id);\n          }\n        });\n\n        return self;\n      }\n\n      // Make sure the to/from/len values are numbers.\n      from = Math.min(Math.max(0, parseFloat(from)), 1);\n      to = Math.min(Math.max(0, parseFloat(to)), 1);\n      len = parseFloat(len);\n\n      // Set the volume to the start position.\n      self.volume(from, id);\n\n      // Fade the volume of one or all sounds.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        // Create a linear fade or fall back to timeouts with HTML5 Audio.\n        if (sound) {\n          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).\n          if (!id) {\n            self._stopFade(ids[i]);\n          }\n\n          // If we are using Web Audio, let the native methods do the actual fade.\n          if (self._webAudio && !sound._muted) {\n            var currentTime = Howler.ctx.currentTime;\n            var end = currentTime + (len / 1000);\n            sound._volume = from;\n            sound._node.gain.setValueAtTime(from, currentTime);\n            sound._node.gain.linearRampToValueAtTime(to, end);\n          }\n\n          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Starts the internal interval to fade a sound.\n     * @param  {Object} sound Reference to sound to fade.\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id to fade.\n     * @param  {Boolean} isGroup   If true, set the volume on the group.\n     */\n    _startFadeInterval: function(sound, from, to, len, id, isGroup) {\n      var self = this;\n      var vol = from;\n      var diff = to - from;\n      var steps = Math.abs(diff / 0.01);\n      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);\n      var lastTick = Date.now();\n\n      // Store the value being faded to.\n      sound._fadeTo = to;\n\n      // Update the volume value on each interval tick.\n      sound._interval = setInterval(function() {\n        // Update the volume based on the time since the last tick.\n        var tick = (Date.now() - lastTick) / len;\n        lastTick = Date.now();\n        vol += diff * tick;\n\n        // Round to within 2 decimal points.\n        vol = Math.round(vol * 100) / 100;\n\n        // Make sure the volume is in the right bounds.\n        if (diff < 0) {\n          vol = Math.max(to, vol);\n        } else {\n          vol = Math.min(to, vol);\n        }\n\n        // Change the volume.\n        if (self._webAudio) {\n          sound._volume = vol;\n        } else {\n          self.volume(vol, sound._id, true);\n        }\n\n        // Set the group's volume.\n        if (isGroup) {\n          self._volume = vol;\n        }\n\n        // When the fade is complete, stop it and fire event.\n        if ((to < from && vol <= to) || (to > from && vol >= to)) {\n          clearInterval(sound._interval);\n          sound._interval = null;\n          sound._fadeTo = null;\n          self.volume(to, sound._id);\n          self._emit('fade', sound._id);\n        }\n      }, stepLen);\n    },\n\n    /**\n     * Internal method that stops the currently playing fade when\n     * a new fade starts, volume is changed or the sound is stopped.\n     * @param  {Number} id The sound id.\n     * @return {Howl}\n     */\n    _stopFade: function(id) {\n      var self = this;\n      var sound = self._soundById(id);\n\n      if (sound && sound._interval) {\n        if (self._webAudio) {\n          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);\n        }\n\n        clearInterval(sound._interval);\n        sound._interval = null;\n        self.volume(sound._fadeTo, id);\n        sound._fadeTo = null;\n        self._emit('fade', id);\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   loop() -> Returns the group's loop value.\n     *   loop(id) -> Returns the sound id's loop value.\n     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.\n     *   loop(loop, id) -> Sets the loop value of passed sound id.\n     * @return {Howl/Boolean} Returns self or current loop value.\n     */\n    loop: function() {\n      var self = this;\n      var args = arguments;\n      var loop, id, sound;\n\n      // Determine the values for loop and id.\n      if (args.length === 0) {\n        // Return the grou's loop value.\n        return self._loop;\n      } else if (args.length === 1) {\n        if (typeof args[0] === 'boolean') {\n          loop = args[0];\n          self._loop = loop;\n        } else {\n          // Return this sound's loop value.\n          sound = self._soundById(parseInt(args[0], 10));\n          return sound ? sound._loop : false;\n        }\n      } else if (args.length === 2) {\n        loop = args[0];\n        id = parseInt(args[1], 10);\n      }\n\n      // If no id is passed, get all ID's to be looped.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._loop = loop;\n          if (self._webAudio && sound._node && sound._node.bufferSource) {\n            sound._node.bufferSource.loop = loop;\n            if (loop) {\n              sound._node.bufferSource.loopStart = sound._start || 0;\n              sound._node.bufferSource.loopEnd = sound._stop;\n\n              // If playing, restart playback to ensure looping updates.\n              if (self.playing(ids[i])) {\n                self.pause(ids[i], true);\n                self.play(ids[i], true);\n              }\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   rate() -> Returns the first sound node's current playback rate.\n     *   rate(id) -> Returns the sound id's current playback rate.\n     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.\n     *   rate(rate, id) -> Sets the playback rate of passed sound id.\n     * @return {Howl/Number} Returns self or the current playback rate.\n     */\n    rate: function() {\n      var self = this;\n      var args = arguments;\n      var rate, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current rate of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new rate value.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          rate = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        rate = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the playback rate or return the current value.\n      var sound;\n      if (typeof rate === 'number') {\n        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.\n        if (self._state !== 'loaded' || self._playLock) {\n          self._queue.push({\n            event: 'rate',\n            action: function() {\n              self.rate.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group rate.\n        if (typeof id === 'undefined') {\n          self._rate = rate;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            // Keep track of our position when the rate changed and update the playback\n            // start position so we can properly adjust the seek position for time elapsed.\n            if (self.playing(id[i])) {\n              sound._rateSeek = self.seek(id[i]);\n              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;\n            }\n            sound._rate = rate;\n\n            // Change the playback rate.\n            if (self._webAudio && sound._node && sound._node.bufferSource) {\n              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);\n            } else if (sound._node) {\n              sound._node.playbackRate = rate;\n            }\n\n            // Reset the timers.\n            var seek = self.seek(id[i]);\n            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;\n            var timeout = (duration * 1000) / Math.abs(sound._rate);\n\n            // Start a new end timer if sound is already playing.\n            if (self._endTimers[id[i]] || !sound._paused) {\n              self._clearTimer(id[i]);\n              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);\n            }\n\n            self._emit('rate', sound._id);\n          }\n        }\n      } else {\n        sound = self._soundById(id);\n        return sound ? sound._rate : self._rate;\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   seek() -> Returns the first sound node's current seek position.\n     *   seek(id) -> Returns the sound id's current seek position.\n     *   seek(seek) -> Sets the seek position of the first sound node.\n     *   seek(seek, id) -> Sets the seek position of passed sound id.\n     * @return {Howl/Number} Returns self or the current seek position.\n     */\n    seek: function() {\n      var self = this;\n      var args = arguments;\n      var seek, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current position of the first node.\n        if (self._sounds.length) {\n          id = self._sounds[0]._id;\n        }\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new seek position.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else if (self._sounds.length) {\n          id = self._sounds[0]._id;\n          seek = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        seek = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // If there is no ID, bail out.\n      if (typeof id === 'undefined') {\n        return 0;\n      }\n\n      // If the sound hasn't loaded, add it to the load queue to seek when capable.\n      if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {\n        self._queue.push({\n          event: 'seek',\n          action: function() {\n            self.seek.apply(self, args);\n          }\n        });\n\n        return self;\n      }\n\n      // Get the sound.\n      var sound = self._soundById(id);\n\n      if (sound) {\n        if (typeof seek === 'number' && seek >= 0) {\n          // Pause the sound and update position for restarting playback.\n          var playing = self.playing(id);\n          if (playing) {\n            self.pause(id, true);\n          }\n\n          // Move the position of the track and cancel timer.\n          sound._seek = seek;\n          sound._ended = false;\n          self._clearTimer(id);\n\n          // Update the seek position for HTML5 Audio.\n          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {\n            sound._node.currentTime = seek;\n          }\n\n          // Seek and emit when ready.\n          var seekAndEmit = function() {\n            // Restart the playback if the sound was playing.\n            if (playing) {\n              self.play(id, true);\n            }\n\n            self._emit('seek', id);\n          };\n\n          // Wait for the play lock to be unset before emitting (HTML5 Audio).\n          if (playing && !self._webAudio) {\n            var emitSeek = function() {\n              if (!self._playLock) {\n                seekAndEmit();\n              } else {\n                setTimeout(emitSeek, 0);\n              }\n            };\n            setTimeout(emitSeek, 0);\n          } else {\n            seekAndEmit();\n          }\n        } else {\n          if (self._webAudio) {\n            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;\n            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;\n            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));\n          } else {\n            return sound._node.currentTime;\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.\n     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.\n     * @return {Boolean} True if playing and false if not.\n     */\n    playing: function(id) {\n      var self = this;\n\n      // Check the passed sound ID (if any).\n      if (typeof id === 'number') {\n        var sound = self._soundById(id);\n        return sound ? !sound._paused : false;\n      }\n\n      // Otherwise, loop through all sounds and check if any are playing.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (!self._sounds[i]._paused) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Get the duration of this sound. Passing a sound id will return the sprite duration.\n     * @param  {Number} id The sound id to check. If none is passed, return full source duration.\n     * @return {Number} Audio duration in seconds.\n     */\n    duration: function(id) {\n      var self = this;\n      var duration = self._duration;\n\n      // If we pass an ID, get the sound and return the sprite length.\n      var sound = self._soundById(id);\n      if (sound) {\n        duration = self._sprite[sound._sprite][1] / 1000;\n      }\n\n      return duration;\n    },\n\n    /**\n     * Returns the current loaded state of this Howl.\n     * @return {String} 'unloaded', 'loading', 'loaded'\n     */\n    state: function() {\n      return this._state;\n    },\n\n    /**\n     * Unload and destroy the current Howl object.\n     * This will immediately stop all sound instances attached to this group.\n     */\n    unload: function() {\n      var self = this;\n\n      // Stop playing any active sounds.\n      var sounds = self._sounds;\n      for (var i=0; i<sounds.length; i++) {\n        // Stop the sound if it is currently playing.\n        if (!sounds[i]._paused) {\n          self.stop(sounds[i]._id);\n        }\n\n        // Remove the source or disconnect.\n        if (!self._webAudio) {\n          // Set the source to 0-second silence to stop any downloading (except in IE).\n          self._clearSound(sounds[i]._node);\n\n          // Remove any event listeners.\n          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);\n          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);\n          sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);\n\n          // Release the Audio object back to the pool.\n          Howler._releaseHtml5Audio(sounds[i]._node);\n        }\n\n        // Empty out all of the nodes.\n        delete sounds[i]._node;\n\n        // Make sure all timers are cleared out.\n        self._clearTimer(sounds[i]._id);\n      }\n\n      // Remove the references in the global Howler object.\n      var index = Howler._howls.indexOf(self);\n      if (index >= 0) {\n        Howler._howls.splice(index, 1);\n      }\n\n      // Delete this sound from the cache (if no other Howl is using it).\n      var remCache = true;\n      for (i=0; i<Howler._howls.length; i++) {\n        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {\n          remCache = false;\n          break;\n        }\n      }\n\n      if (cache && remCache) {\n        delete cache[self._src];\n      }\n\n      // Clear global errors.\n      Howler.noAudio = false;\n\n      // Clear out `self`.\n      self._state = 'unloaded';\n      self._sounds = [];\n      self = null;\n\n      return null;\n    },\n\n    /**\n     * Listen to a custom event.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.\n     * @return {Howl}\n     */\n    on: function(event, fn, id, once) {\n      var self = this;\n      var events = self['_on' + event];\n\n      if (typeof fn === 'function') {\n        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});\n      }\n\n      return self;\n    },\n\n    /**\n     * Remove a custom event. Call without parameters to remove all events.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to remove. Leave empty to remove all.\n     * @param  {Number}   id    (optional) Only remove events for this sound.\n     * @return {Howl}\n     */\n    off: function(event, fn, id) {\n      var self = this;\n      var events = self['_on' + event];\n      var i = 0;\n\n      // Allow passing just an event and ID.\n      if (typeof fn === 'number') {\n        id = fn;\n        fn = null;\n      }\n\n      if (fn || id) {\n        // Loop through event store and remove the passed function.\n        for (i=0; i<events.length; i++) {\n          var isId = (id === events[i].id);\n          if (fn === events[i].fn && isId || !fn && isId) {\n            events.splice(i, 1);\n            break;\n          }\n        }\n      } else if (event) {\n        // Clear out all events of this type.\n        self['_on' + event] = [];\n      } else {\n        // Clear out all events of every type.\n        var keys = Object.keys(self);\n        for (i=0; i<keys.length; i++) {\n          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {\n            self[keys[i]] = [];\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Listen to a custom event and remove it once fired.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @return {Howl}\n     */\n    once: function(event, fn, id) {\n      var self = this;\n\n      // Setup the event listener.\n      self.on(event, fn, id, 1);\n\n      return self;\n    },\n\n    /**\n     * Emit all events of a specific type and pass the sound id.\n     * @param  {String} event Event name.\n     * @param  {Number} id    Sound ID.\n     * @param  {Number} msg   Message to go with event.\n     * @return {Howl}\n     */\n    _emit: function(event, id, msg) {\n      var self = this;\n      var events = self['_on' + event];\n\n      // Loop through event store and fire all functions.\n      for (var i=events.length-1; i>=0; i--) {\n        // Only fire the listener if the correct ID is used.\n        if (!events[i].id || events[i].id === id || event === 'load') {\n          setTimeout(function(fn) {\n            fn.call(this, id, msg);\n          }.bind(self, events[i].fn), 0);\n\n          // If this event was setup with `once`, remove it.\n          if (events[i].once) {\n            self.off(event, events[i].fn, events[i].id);\n          }\n        }\n      }\n\n      // Pass the event type into load queue so that it can continue stepping.\n      self._loadQueue(event);\n\n      return self;\n    },\n\n    /**\n     * Queue of actions initiated before the sound has loaded.\n     * These will be called in sequence, with the next only firing\n     * after the previous has finished executing (even if async like play).\n     * @return {Howl}\n     */\n    _loadQueue: function(event) {\n      var self = this;\n\n      if (self._queue.length > 0) {\n        var task = self._queue[0];\n\n        // Remove this task if a matching event was passed.\n        if (task.event === event) {\n          self._queue.shift();\n          self._loadQueue();\n        }\n\n        // Run the task if no event type is passed.\n        if (!event) {\n          task.action();\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Fired when playback ends at the end of the duration.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _ended: function(sound) {\n      var self = this;\n      var sprite = sound._sprite;\n\n      // If we are using IE and there was network latency we may be clipping\n      // audio before it completes playing. Lets check the node to make sure it\n      // believes it has completed, before ending the playback.\n      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {\n        setTimeout(self._ended.bind(self, sound), 100);\n        return self;\n      }\n\n      // Should this sound loop?\n      var loop = !!(sound._loop || self._sprite[sprite][2]);\n\n      // Fire the ended event.\n      self._emit('end', sound._id);\n\n      // Restart the playback for HTML5 Audio loop.\n      if (!self._webAudio && loop) {\n        self.stop(sound._id, true).play(sound._id);\n      }\n\n      // Restart this timer if on a Web Audio loop.\n      if (self._webAudio && loop) {\n        self._emit('play', sound._id);\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        sound._playStart = Howler.ctx.currentTime;\n\n        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);\n        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n      }\n\n      // Mark the node as paused.\n      if (self._webAudio && !loop) {\n        sound._paused = true;\n        sound._ended = true;\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        self._clearTimer(sound._id);\n\n        // Clean up the buffer source.\n        self._cleanBuffer(sound._node);\n\n        // Attempt to auto-suspend AudioContext if no sounds are still playing.\n        Howler._autoSuspend();\n      }\n\n      // When using a sprite, end the track.\n      if (!self._webAudio && !loop) {\n        self.stop(sound._id, true);\n      }\n\n      return self;\n    },\n\n    /**\n     * Clear the end timer for a sound playback.\n     * @param  {Number} id The sound ID.\n     * @return {Howl}\n     */\n    _clearTimer: function(id) {\n      var self = this;\n\n      if (self._endTimers[id]) {\n        // Clear the timeout or remove the ended listener.\n        if (typeof self._endTimers[id] !== 'function') {\n          clearTimeout(self._endTimers[id]);\n        } else {\n          var sound = self._soundById(id);\n          if (sound && sound._node) {\n            sound._node.removeEventListener('ended', self._endTimers[id], false);\n          }\n        }\n\n        delete self._endTimers[id];\n      }\n\n      return self;\n    },\n\n    /**\n     * Return the sound identified by this ID, or return null.\n     * @param  {Number} id Sound ID\n     * @return {Object}    Sound object or null.\n     */\n    _soundById: function(id) {\n      var self = this;\n\n      // Loop through all sounds and find the one with this ID.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (id === self._sounds[i]._id) {\n          return self._sounds[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Return an inactive sound from the pool or create a new one.\n     * @return {Sound} Sound playback object.\n     */\n    _inactiveSound: function() {\n      var self = this;\n\n      self._drain();\n\n      // Find the first inactive node to recycle.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          return self._sounds[i].reset();\n        }\n      }\n\n      // If no inactive node was found, create a new one.\n      return new Sound(self);\n    },\n\n    /**\n     * Drain excess inactive sounds from the pool.\n     */\n    _drain: function() {\n      var self = this;\n      var limit = self._pool;\n      var cnt = 0;\n      var i = 0;\n\n      // If there are less sounds than the max pool size, we are done.\n      if (self._sounds.length < limit) {\n        return;\n      }\n\n      // Count the number of inactive sounds.\n      for (i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          cnt++;\n        }\n      }\n\n      // Remove excess inactive sounds, going in reverse order.\n      for (i=self._sounds.length - 1; i>=0; i--) {\n        if (cnt <= limit) {\n          return;\n        }\n\n        if (self._sounds[i]._ended) {\n          // Disconnect the audio source when using Web Audio.\n          if (self._webAudio && self._sounds[i]._node) {\n            self._sounds[i]._node.disconnect(0);\n          }\n\n          // Remove sounds until we have the pool size.\n          self._sounds.splice(i, 1);\n          cnt--;\n        }\n      }\n    },\n\n    /**\n     * Get all ID's from the sounds pool.\n     * @param  {Number} id Only return one ID if one is passed.\n     * @return {Array}    Array of IDs.\n     */\n    _getSoundIds: function(id) {\n      var self = this;\n\n      if (typeof id === 'undefined') {\n        var ids = [];\n        for (var i=0; i<self._sounds.length; i++) {\n          ids.push(self._sounds[i]._id);\n        }\n\n        return ids;\n      } else {\n        return [id];\n      }\n    },\n\n    /**\n     * Load the sound back into the buffer source.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _refreshBuffer: function(sound) {\n      var self = this;\n\n      // Setup the buffer source for playback.\n      sound._node.bufferSource = Howler.ctx.createBufferSource();\n      sound._node.bufferSource.buffer = cache[self._src];\n\n      // Connect to the correct node.\n      if (sound._panner) {\n        sound._node.bufferSource.connect(sound._panner);\n      } else {\n        sound._node.bufferSource.connect(sound._node);\n      }\n\n      // Setup looping and playback rate.\n      sound._node.bufferSource.loop = sound._loop;\n      if (sound._loop) {\n        sound._node.bufferSource.loopStart = sound._start || 0;\n        sound._node.bufferSource.loopEnd = sound._stop || 0;\n      }\n      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);\n\n      return self;\n    },\n\n    /**\n     * Prevent memory leaks by cleaning up the buffer source after playback.\n     * @param  {Object} node Sound's audio node containing the buffer source.\n     * @return {Howl}\n     */\n    _cleanBuffer: function(node) {\n      var self = this;\n      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;\n\n      if (Howler._scratchBuffer && node.bufferSource) {\n        node.bufferSource.onended = null;\n        node.bufferSource.disconnect(0);\n        if (isIOS) {\n          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}\n        }\n      }\n      node.bufferSource = null;\n\n      return self;\n    },\n\n    /**\n     * Set the source to a 0-second silence to stop any downloading (except in IE).\n     * @param  {Object} node Audio node to clear.\n     */\n    _clearSound: function(node) {\n      var checkIE = /MSIE |Trident\\//.test(Howler._navigator && Howler._navigator.userAgent);\n      if (!checkIE) {\n        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';\n      }\n    }\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Setup the sound object, which each node attached to a Howl group is contained in.\n   * @param {Object} howl The Howl parent group.\n   */\n  var Sound = function(howl) {\n    this._parent = howl;\n    this.init();\n  };\n  Sound.prototype = {\n    /**\n     * Initialize a new Sound object.\n     * @return {Sound}\n     */\n    init: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup the default parameters.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a unique ID for this sound.\n      self._id = ++Howler._counter;\n\n      // Add itself to the parent's pool.\n      parent._sounds.push(self);\n\n      // Create the new node.\n      self.create();\n\n      return self;\n    },\n\n    /**\n     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.\n     * @return {Sound}\n     */\n    create: function() {\n      var self = this;\n      var parent = self._parent;\n      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;\n\n      if (parent._webAudio) {\n        // Create the gain node for controlling volume (the source will connect to this).\n        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);\n        self._node.paused = true;\n        self._node.connect(Howler.masterGain);\n      } else if (!Howler.noAudio) {\n        // Get an unlocked Audio object from the pool.\n        self._node = Howler._obtainHtml5Audio();\n\n        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).\n        self._errorFn = self._errorListener.bind(self);\n        self._node.addEventListener('error', self._errorFn, false);\n\n        // Listen for 'canplaythrough' event to let us know the sound is ready.\n        self._loadFn = self._loadListener.bind(self);\n        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);\n\n        // Listen for the 'ended' event on the sound to account for edge-case where\n        // a finite sound has a duration of Infinity.\n        self._endFn = self._endListener.bind(self);\n        self._node.addEventListener('ended', self._endFn, false);\n\n        // Setup the new audio node.\n        self._node.src = parent._src;\n        self._node.preload = parent._preload === true ? 'auto' : parent._preload;\n        self._node.volume = volume * Howler.volume();\n\n        // Begin loading the source.\n        self._node.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Reset the parameters of this sound to the original state (for recycle).\n     * @return {Sound}\n     */\n    reset: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all of the parameters of this sound.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._rateSeek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a new ID so that it isn't confused with the previous sound.\n      self._id = ++Howler._counter;\n\n      return self;\n    },\n\n    /**\n     * HTML5 Audio error listener callback.\n     */\n    _errorListener: function() {\n      var self = this;\n\n      // Fire an error event and pass back the code.\n      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);\n\n      // Clear the event listener.\n      self._node.removeEventListener('error', self._errorFn, false);\n    },\n\n    /**\n     * HTML5 Audio canplaythrough listener callback.\n     */\n    _loadListener: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Round up the duration to account for the lower precision in HTML5 Audio.\n      parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n      // Setup a sprite if none is defined.\n      if (Object.keys(parent._sprite).length === 0) {\n        parent._sprite = {__default: [0, parent._duration * 1000]};\n      }\n\n      if (parent._state !== 'loaded') {\n        parent._state = 'loaded';\n        parent._emit('load');\n        parent._loadQueue();\n      }\n\n      // Clear the event listener.\n      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);\n    },\n\n    /**\n     * HTML5 Audio ended listener callback.\n     */\n    _endListener: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Only handle the `ended`` event if the duration is Infinity.\n      if (parent._duration === Infinity) {\n        // Update the parent duration to match the real audio duration.\n        // Round up the duration to account for the lower precision in HTML5 Audio.\n        parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n        // Update the sprite that corresponds to the real duration.\n        if (parent._sprite.__default[1] === Infinity) {\n          parent._sprite.__default[1] = parent._duration * 1000;\n        }\n\n        // Run the regular ended method.\n        parent._ended(self);\n      }\n\n      // Clear the event listener since the duration is now correct.\n      self._node.removeEventListener('ended', self._endFn, false);\n    }\n  };\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  var cache = {};\n\n  /**\n   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).\n   * @param  {Howl} self\n   */\n  var loadBuffer = function(self) {\n    var url = self._src;\n\n    // Check if the buffer has already been cached and use it instead.\n    if (cache[url]) {\n      // Set the duration from the cache.\n      self._duration = cache[url].duration;\n\n      // Load the sound into this Howl.\n      loadSound(self);\n\n      return;\n    }\n\n    if (/^data:[^;]+;base64,/.test(url)) {\n      // Decode the base64 data URI without XHR, since some browsers don't support it.\n      var data = atob(url.split(',')[1]);\n      var dataView = new Uint8Array(data.length);\n      for (var i=0; i<data.length; ++i) {\n        dataView[i] = data.charCodeAt(i);\n      }\n\n      decodeAudioData(dataView.buffer, self);\n    } else {\n      // Load the buffer from the URL.\n      var xhr = new XMLHttpRequest();\n      xhr.open(self._xhr.method, url, true);\n      xhr.withCredentials = self._xhr.withCredentials;\n      xhr.responseType = 'arraybuffer';\n\n      // Apply any custom headers to the request.\n      if (self._xhr.headers) {\n        Object.keys(self._xhr.headers).forEach(function(key) {\n          xhr.setRequestHeader(key, self._xhr.headers[key]);\n        });\n      }\n\n      xhr.onload = function() {\n        // Make sure we get a successful response back.\n        var code = (xhr.status + '')[0];\n        if (code !== '0' && code !== '2' && code !== '3') {\n          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');\n          return;\n        }\n\n        decodeAudioData(xhr.response, self);\n      };\n      xhr.onerror = function() {\n        // If there is an error, switch to HTML5 Audio.\n        if (self._webAudio) {\n          self._html5 = true;\n          self._webAudio = false;\n          self._sounds = [];\n          delete cache[url];\n          self.load();\n        }\n      };\n      safeXhrSend(xhr);\n    }\n  };\n\n  /**\n   * Send the XHR request wrapped in a try/catch.\n   * @param  {Object} xhr XHR to send.\n   */\n  var safeXhrSend = function(xhr) {\n    try {\n      xhr.send();\n    } catch (e) {\n      xhr.onerror();\n    }\n  };\n\n  /**\n   * Decode audio data from an array buffer.\n   * @param  {ArrayBuffer} arraybuffer The audio data.\n   * @param  {Howl}        self\n   */\n  var decodeAudioData = function(arraybuffer, self) {\n    // Fire a load error if something broke.\n    var error = function() {\n      self._emit('loaderror', null, 'Decoding audio data failed.');\n    };\n\n    // Load the sound on success.\n    var success = function(buffer) {\n      if (buffer && self._sounds.length > 0) {\n        cache[self._src] = buffer;\n        loadSound(self, buffer);\n      } else {\n        error();\n      }\n    };\n\n    // Decode the buffer into an audio source.\n    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {\n      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);\n    } else {\n      Howler.ctx.decodeAudioData(arraybuffer, success, error);\n    }\n  }\n\n  /**\n   * Sound is now loaded, so finish setting everything up and fire the loaded event.\n   * @param  {Howl} self\n   * @param  {Object} buffer The decoded buffer sound source.\n   */\n  var loadSound = function(self, buffer) {\n    // Set the duration.\n    if (buffer && !self._duration) {\n      self._duration = buffer.duration;\n    }\n\n    // Setup a sprite if none is defined.\n    if (Object.keys(self._sprite).length === 0) {\n      self._sprite = {__default: [0, self._duration * 1000]};\n    }\n\n    // Fire the loaded event.\n    if (self._state !== 'loaded') {\n      self._state = 'loaded';\n      self._emit('load');\n      self._loadQueue();\n    }\n  };\n\n  /**\n   * Setup the audio context when available, or switch to HTML5 Audio mode.\n   */\n  var setupAudioContext = function() {\n    // If we have already detected that Web Audio isn't supported, don't run this step again.\n    if (!Howler.usingWebAudio) {\n      return;\n    }\n\n    // Check if we are using Web Audio and setup the AudioContext if we are.\n    try {\n      if (typeof AudioContext !== 'undefined') {\n        Howler.ctx = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Howler.ctx = new webkitAudioContext();\n      } else {\n        Howler.usingWebAudio = false;\n      }\n    } catch(e) {\n      Howler.usingWebAudio = false;\n    }\n\n    // If the audio context creation still failed, set using web audio to false.\n    if (!Howler.ctx) {\n      Howler.usingWebAudio = false;\n    }\n\n    // Check if a webview is being used on iOS8 or earlier (rather than the browser).\n    // If it is, disable Web Audio as it causes crashing.\n    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));\n    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n    var version = appVersion ? parseInt(appVersion[1], 10) : null;\n    if (iOS && version && version < 9) {\n      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());\n      if (Howler._navigator && !safari) {\n        Howler.usingWebAudio = false;\n      }\n    }\n\n    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).\n    if (Howler.usingWebAudio) {\n      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);\n      Howler.masterGain.connect(Howler.ctx.destination);\n    }\n\n    // Re-run the setup on Howler.\n    Howler._setup();\n  };\n\n  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return {\n        Howler: Howler,\n        Howl: Howl\n      };\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  // Add support for CommonJS libraries such as browserify.\n  if (true) {\n    exports.Howler = Howler;\n    exports.Howl = Howl;\n  }\n\n  // Add to global in Node.js (for testing, etc).\n  if (typeof __webpack_require__.g !== 'undefined') {\n    __webpack_require__.g.HowlerGlobal = HowlerGlobal;\n    __webpack_require__.g.Howler = Howler;\n    __webpack_require__.g.Howl = Howl;\n    __webpack_require__.g.Sound = Sound;\n  } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.\n    window.HowlerGlobal = HowlerGlobal;\n    window.Howler = Howler;\n    window.Howl = Howl;\n    window.Sound = Sound;\n  }\n})();\n\n\n/*!\n *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.\n *  \n *  howler.js v2.2.3\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  // Setup default properties.\n  HowlerGlobal.prototype._pos = [0, 0, 0];\n  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Helper method to update the stereo panning position of all current Howls.\n   * Future Howls will not use this value unless explicitly set.\n   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @return {Howler/Number}     Self or current stereo panning value.\n   */\n  HowlerGlobal.prototype.stereo = function(pan) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Loop through all Howls and update their stereo panning.\n    for (var i=self._howls.length-1; i>=0; i--) {\n      self._howls[i].stereo(pan);\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the position of the listener in 3D cartesian space. Sounds using\n   * 3D position will be relative to the listener's position.\n   * @param  {Number} x The x-position of the listener.\n   * @param  {Number} y The y-position of the listener.\n   * @param  {Number} z The z-position of the listener.\n   * @return {Howler/Array}   Self or current listener position.\n   */\n  HowlerGlobal.prototype.pos = function(x, y, z) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._pos[1] : y;\n    z = (typeof z !== 'number') ? self._pos[2] : z;\n\n    if (typeof x === 'number') {\n      self._pos = [x, y, z];\n\n      if (typeof self.ctx.listener.positionX !== 'undefined') {\n        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);\n      } else {\n        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);\n      }\n    } else {\n      return self._pos;\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the listener is pointing in the 3D cartesian space.\n   * A front and up vector must be provided. The front is the direction the\n   * face of the listener is pointing, and up is the direction the top of the\n   * listener is pointing. Thus, these values are expected to be at right angles\n   * from each other.\n   * @param  {Number} x   The x-orientation of the listener.\n   * @param  {Number} y   The y-orientation of the listener.\n   * @param  {Number} z   The z-orientation of the listener.\n   * @param  {Number} xUp The x-orientation of the top of the listener.\n   * @param  {Number} yUp The y-orientation of the top of the listener.\n   * @param  {Number} zUp The z-orientation of the top of the listener.\n   * @return {Howler/Array}     Returns self or the current orientation vectors.\n   */\n  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    var or = self._orientation;\n    y = (typeof y !== 'number') ? or[1] : y;\n    z = (typeof z !== 'number') ? or[2] : z;\n    xUp = (typeof xUp !== 'number') ? or[3] : xUp;\n    yUp = (typeof yUp !== 'number') ? or[4] : yUp;\n    zUp = (typeof zUp !== 'number') ? or[5] : zUp;\n\n    if (typeof x === 'number') {\n      self._orientation = [x, y, z, xUp, yUp, zUp];\n\n      if (typeof self.ctx.listener.forwardX !== 'undefined') {\n        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);\n      } else {\n        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);\n      }\n    } else {\n      return or;\n    }\n\n    return self;\n  };\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core init.\n   * @param  {Function} _super Core init method.\n   * @return {Howl}\n   */\n  Howl.prototype.init = (function(_super) {\n    return function(o) {\n      var self = this;\n\n      // Setup user-defined default properties.\n      self._orientation = o.orientation || [1, 0, 0];\n      self._stereo = o.stereo || null;\n      self._pos = o.pos || null;\n      self._pannerAttr = {\n        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,\n        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,\n        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,\n        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',\n        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,\n        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',\n        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,\n        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1\n      };\n\n      // Setup event listeners.\n      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];\n      self._onpos = o.onpos ? [{fn: o.onpos}] : [];\n      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];\n\n      // Complete initilization with howler.js core's init function.\n      return _super.call(this, o);\n    };\n  })(Howl.prototype.init);\n\n  /**\n   * Get/set the stereo panning of the audio source for this sound or all in the group.\n   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Number}    Returns self or the current stereo panning value.\n   */\n  Howl.prototype.stereo = function(pan, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'stereo',\n        action: function() {\n          self.stereo(pan, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.\n    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';\n\n    // Setup the group's stereo panning if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's stereo panning if no parameters are passed.\n      if (typeof pan === 'number') {\n        self._stereo = pan;\n        self._pos = [pan, 0, 0];\n      } else {\n        return self._stereo;\n      }\n    }\n\n    // Change the streo panning of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof pan === 'number') {\n          sound._stereo = pan;\n          sound._pos = [pan, 0, 0];\n\n          if (sound._node) {\n            // If we are falling back, make sure the panningModel is equalpower.\n            sound._pannerAttr.panningModel = 'equalpower';\n\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || !sound._panner.pan) {\n              setupPanner(sound, pannerType);\n            }\n\n            if (pannerType === 'spatial') {\n              if (typeof sound._panner.positionX !== 'undefined') {\n                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);\n                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);\n                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);\n              } else {\n                sound._panner.setPosition(pan, 0, 0);\n              }\n            } else {\n              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);\n            }\n          }\n\n          self._emit('stereo', sound._id);\n        } else {\n          return sound._stereo;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.\n   * @param  {Number} x  The x-position of the audio source.\n   * @param  {Number} y  The y-position of the audio source.\n   * @param  {Number} z  The z-position of the audio source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].\n   */\n  Howl.prototype.pos = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change position when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'pos',\n        action: function() {\n          self.pos(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? 0 : y;\n    z = (typeof z !== 'number') ? -0.5 : z;\n\n    // Setup the group's spatial position if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial position if no parameters are passed.\n      if (typeof x === 'number') {\n        self._pos = [x, y, z];\n      } else {\n        return self._pos;\n      }\n    }\n\n    // Change the spatial position of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._pos = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || sound._panner.pan) {\n              setupPanner(sound, 'spatial');\n            }\n\n            if (typeof sound._panner.positionX !== 'undefined') {\n              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);\n              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);\n              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);\n            } else {\n              sound._panner.setPosition(x, y, z);\n            }\n          }\n\n          self._emit('pos', sound._id);\n        } else {\n          return sound._pos;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate\n   * space. Depending on how direction the sound is, based on the `cone` attributes,\n   * a sound pointing away from the listener can be quiet or silent.\n   * @param  {Number} x  The x-orientation of the source.\n   * @param  {Number} y  The y-orientation of the source.\n   * @param  {Number} z  The z-orientation of the source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].\n   */\n  Howl.prototype.orientation = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'orientation',\n        action: function() {\n          self.orientation(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._orientation[1] : y;\n    z = (typeof z !== 'number') ? self._orientation[2] : z;\n\n    // Setup the group's spatial orientation if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial orientation if no parameters are passed.\n      if (typeof x === 'number') {\n        self._orientation = [x, y, z];\n      } else {\n        return self._orientation;\n      }\n    }\n\n    // Change the spatial orientation of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._orientation = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner) {\n              // Make sure we have a position to setup the node with.\n              if (!sound._pos) {\n                sound._pos = self._pos || [0, 0, -0.5];\n              }\n\n              setupPanner(sound, 'spatial');\n            }\n\n            if (typeof sound._panner.orientationX !== 'undefined') {\n              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);\n              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);\n              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);\n            } else {\n              sound._panner.setOrientation(x, y, z);\n            }\n          }\n\n          self._emit('orientation', sound._id);\n        } else {\n          return sound._orientation;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the panner node's attributes for a sound or group of sounds.\n   * This method can optionall take 0, 1 or 2 arguments.\n   *   pannerAttr() -> Returns the group's values.\n   *   pannerAttr(id) -> Returns the sound id's values.\n   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.\n   *   pannerAttr(o, id) -> Set's the values of passed sound id.\n   *\n   *   Attributes:\n   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      inside of which there will be no volume reduction.\n   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.\n   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the\n   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.\n   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from\n   *                     listener. Can be `linear`, `inverse` or `exponential.\n   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume\n   *                   will not be reduced any further.\n   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.\n   *                   This is simply a variable of the distance model and has a different effect depending on which model\n   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.\n   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a\n   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`\n   *                     with `inverse` and `exponential`.\n   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.\n   *                     Can be `HRTF` or `equalpower`.\n   *\n   * @return {Howl/Object} Returns self or current panner attributes.\n   */\n  Howl.prototype.pannerAttr = function() {\n    var self = this;\n    var args = arguments;\n    var o, id, sound;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // Determine the values based on arguments.\n    if (args.length === 0) {\n      // Return the group's panner attribute values.\n      return self._pannerAttr;\n    } else if (args.length === 1) {\n      if (typeof args[0] === 'object') {\n        o = args[0];\n\n        // Set the grou's panner attribute values.\n        if (typeof id === 'undefined') {\n          if (!o.pannerAttr) {\n            o.pannerAttr = {\n              coneInnerAngle: o.coneInnerAngle,\n              coneOuterAngle: o.coneOuterAngle,\n              coneOuterGain: o.coneOuterGain,\n              distanceModel: o.distanceModel,\n              maxDistance: o.maxDistance,\n              refDistance: o.refDistance,\n              rolloffFactor: o.rolloffFactor,\n              panningModel: o.panningModel\n            };\n          }\n\n          self._pannerAttr = {\n            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,\n            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,\n            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,\n            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,\n            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,\n            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,\n            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,\n            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel\n          };\n        }\n      } else {\n        // Return this sound's panner attribute values.\n        sound = self._soundById(parseInt(args[0], 10));\n        return sound ? sound._pannerAttr : self._pannerAttr;\n      }\n    } else if (args.length === 2) {\n      o = args[0];\n      id = parseInt(args[1], 10);\n    }\n\n    // Update the values of the specified sounds.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      sound = self._soundById(ids[i]);\n\n      if (sound) {\n        // Merge the new values into the sound.\n        var pa = sound._pannerAttr;\n        pa = {\n          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,\n          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,\n          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,\n          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,\n          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,\n          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,\n          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,\n          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel\n        };\n\n        // Update the panner values or create a new panner if none exists.\n        var panner = sound._panner;\n        if (panner) {\n          panner.coneInnerAngle = pa.coneInnerAngle;\n          panner.coneOuterAngle = pa.coneOuterAngle;\n          panner.coneOuterGain = pa.coneOuterGain;\n          panner.distanceModel = pa.distanceModel;\n          panner.maxDistance = pa.maxDistance;\n          panner.refDistance = pa.refDistance;\n          panner.rolloffFactor = pa.rolloffFactor;\n          panner.panningModel = pa.panningModel;\n        } else {\n          // Make sure we have a position to setup the node with.\n          if (!sound._pos) {\n            sound._pos = self._pos || [0, 0, -0.5];\n          }\n\n          // Create a new panner node.\n          setupPanner(sound, 'spatial');\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core Sound init.\n   * @param  {Function} _super Core Sound init method.\n   * @return {Sound}\n   */\n  Sound.prototype.init = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup user-defined default properties.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // Complete initilization with howler.js core Sound's init function.\n      _super.call(this);\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      }\n    };\n  })(Sound.prototype.init);\n\n  /**\n   * Override the Sound.reset method to clean up properties from the spatial plugin.\n   * @param  {Function} _super Sound reset method.\n   * @return {Sound}\n   */\n  Sound.prototype.reset = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all spatial plugin properties on this sound.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      } else if (self._panner) {\n        // Disconnect the panner.\n        self._panner.disconnect(0);\n        self._panner = undefined;\n        parent._refreshBuffer(self);\n      }\n\n      // Complete resetting of the sound.\n      return _super.call(this);\n    };\n  })(Sound.prototype.reset);\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create a new panner node and save it on the sound.\n   * @param  {Sound} sound Specific sound to setup panning on.\n   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.\n   */\n  var setupPanner = function(sound, type) {\n    type = type || 'spatial';\n\n    // Create the new panner node.\n    if (type === 'spatial') {\n      sound._panner = Howler.ctx.createPanner();\n      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;\n      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;\n      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;\n      sound._panner.distanceModel = sound._pannerAttr.distanceModel;\n      sound._panner.maxDistance = sound._pannerAttr.maxDistance;\n      sound._panner.refDistance = sound._pannerAttr.refDistance;\n      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;\n      sound._panner.panningModel = sound._pannerAttr.panningModel;\n\n      if (typeof sound._panner.positionX !== 'undefined') {\n        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);\n        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);\n        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);\n      } else {\n        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);\n      }\n\n      if (typeof sound._panner.orientationX !== 'undefined') {\n        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);\n        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);\n        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);\n      } else {\n        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);\n      }\n    } else {\n      sound._panner = Howler.ctx.createStereoPanner();\n      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);\n    }\n\n    sound._panner.connect(sound._node);\n\n    // Update the connections.\n    if (!sound._paused) {\n      sound._parent.pause(sound._id, true).play(sound._id, true);\n    }\n  };\n})();\n\n\n//# sourceURL=webpack://intro-webpack/./src/js/howler.js?");

/***/ }),

/***/ "./src/js/luxon.js":
/*!*************************!*\
  !*** ./src/js/luxon.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DateTime\": () => (/* binding */ Wr),\n/* harmony export */   \"Duration\": () => (/* binding */ _t),\n/* harmony export */   \"FixedOffsetZone\": () => (/* binding */ Ve),\n/* harmony export */   \"IANAZone\": () => (/* binding */ De),\n/* harmony export */   \"Info\": () => (/* binding */ Rt),\n/* harmony export */   \"Interval\": () => (/* binding */ Wt),\n/* harmony export */   \"InvalidZone\": () => (/* binding */ Ie),\n/* harmony export */   \"Settings\": () => (/* binding */ qe),\n/* harmony export */   \"SystemZone\": () => (/* binding */ Oe),\n/* harmony export */   \"VERSION\": () => (/* binding */ Xe),\n/* harmony export */   \"Zone\": () => (/* binding */ Te)\n/* harmony export */ });\nclass e extends Error {}\nclass r extends e {\n  constructor(e) {\n    super(`Invalid DateTime: ${e.toMessage()}`);\n  }\n}\nclass n extends e {\n  constructor(e) {\n    super(`Invalid Interval: ${e.toMessage()}`);\n  }\n}\nclass s extends e {\n  constructor(e) {\n    super(`Invalid Duration: ${e.toMessage()}`);\n  }\n}\nclass N extends e {}\nclass i extends e {\n  constructor(e) {\n    super(`Invalid unit ${e}`);\n  }\n}\nclass a extends e {}\nclass o extends e {\n  constructor() {\n    super(\"Zone is an abstract class\");\n  }\n}\nvar t = \"numeric\",\n  u = \"short\",\n  l = \"long\";\nconst c = { year: t, month: t, day: t },\n  h = { year: t, month: u, day: t },\n  d = { year: t, month: u, day: t, weekday: u },\n  m = { year: t, month: l, day: t },\n  f = { year: t, month: l, day: t, weekday: l },\n  y = { hour: t, minute: t },\n  g = { hour: t, minute: t, second: t },\n  w = { hour: t, minute: t, second: t, timeZoneName: u },\n  p = { hour: t, minute: t, second: t, timeZoneName: l },\n  v = { hour: t, minute: t, hourCycle: \"h23\" },\n  T = { hour: t, minute: t, second: t, hourCycle: \"h23\" },\n  S = { hour: t, minute: t, second: t, hourCycle: \"h23\", timeZoneName: u },\n  O = { hour: t, minute: t, second: t, hourCycle: \"h23\", timeZoneName: l },\n  b = { year: t, month: t, day: t, hour: t, minute: t },\n  M = { year: t, month: t, day: t, hour: t, minute: t, second: t },\n  k = { year: t, month: u, day: t, hour: t, minute: t },\n  D = { year: t, month: u, day: t, hour: t, minute: t, second: t },\n  E = { year: t, month: u, day: t, weekday: u, hour: t, minute: t },\n  V = { year: t, month: l, day: t, hour: t, minute: t, timeZoneName: u },\n  I = {\n    year: t,\n    month: l,\n    day: t,\n    hour: t,\n    minute: t,\n    second: t,\n    timeZoneName: u,\n  },\n  x = {\n    year: t,\n    month: l,\n    day: t,\n    weekday: l,\n    hour: t,\n    minute: t,\n    timeZoneName: l,\n  },\n  C = {\n    year: t,\n    month: l,\n    day: t,\n    weekday: l,\n    hour: t,\n    minute: t,\n    second: t,\n    timeZoneName: l,\n  };\nfunction $(e) {\n  return void 0 === e;\n}\nfunction Z(e) {\n  return \"number\" == typeof e;\n}\nfunction F(e) {\n  return \"number\" == typeof e && e % 1 == 0;\n}\nfunction L() {\n  try {\n    return \"undefined\" != typeof Intl && !!Intl.RelativeTimeFormat;\n  } catch (e) {\n    return !1;\n  }\n}\nfunction z(e, r, n) {\n  if (0 !== e.length)\n    return e.reduce((e, t) => {\n      t = [r(t), t];\n      return e && n(e[0], t[0]) === e[0] ? e : t;\n    }, null)[1];\n}\nfunction q(e, t) {\n  return Object.prototype.hasOwnProperty.call(e, t);\n}\nfunction A(e, t, r) {\n  return F(e) && t <= e && e <= r;\n}\nfunction j(e, t = 2) {\n  var r = e < 0 ? \"-\" : \"\";\n  const n = r ? -1 * e : e;\n  let s;\n  return (\n    (s =\n      n.toString().length < t ? (\"0\".repeat(t) + n).slice(-t) : n.toString()),\n    `${r}${s}`\n  );\n}\nfunction _(e) {\n  if (!$(e) && null !== e && \"\" !== e) return parseInt(e, 10);\n}\nfunction U(e) {\n  if (!$(e) && null !== e && \"\" !== e) {\n    e = 1e3 * parseFloat(\"0.\" + e);\n    return Math.floor(e);\n  }\n}\nfunction H(e, t, r = !1) {\n  const n = 10 ** t,\n    s = r ? Math.trunc : Math.round;\n  return s(e * n) / n;\n}\nfunction W(e) {\n  return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0);\n}\nfunction R(e) {\n  return W(e) ? 366 : 365;\n}\nfunction P(e, t) {\n  var r,\n    n,\n    n = (r = t - 1) - (n = 12) * Math.floor(r / n) + 1;\n  return 2 == n\n    ? W(e + (t - n) / 12)\n      ? 29\n      : 28\n    : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][n - 1];\n}\nfunction J(e) {\n  let t = Date.UTC(\n    e.year,\n    e.month - 1,\n    e.day,\n    e.hour,\n    e.minute,\n    e.second,\n    e.millisecond\n  );\n  return (\n    e.year < 100 &&\n      0 <= e.year &&\n      ((t = new Date(t)), t.setUTCFullYear(t.getUTCFullYear() - 1900)),\n    +t\n  );\n}\nfunction Y(e) {\n  var t =\n      (e + Math.floor(e / 4) - Math.floor(e / 100) + Math.floor(e / 400)) % 7,\n    e = e - 1,\n    e = (e + Math.floor(e / 4) - Math.floor(e / 100) + Math.floor(e / 400)) % 7;\n  return 4 == t || 3 == e ? 53 : 52;\n}\nfunction G(e) {\n  return 99 < e ? e : 60 < e ? 1900 + e : 2e3 + e;\n}\nfunction B(e, t, r, n = null) {\n  const s = new Date(e),\n    i = {\n      hourCycle: \"h23\",\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    };\n  n && (i.timeZone = n);\n  (t = { timeZoneName: t, ...i }),\n    (t = new Intl.DateTimeFormat(r, t)\n      .formatToParts(s)\n      .find((e) => \"timezonename\" === e.type.toLowerCase()));\n  return t ? t.value : null;\n}\nfunction Q(e, t) {\n  let r = parseInt(e, 10);\n  Number.isNaN(r) && (r = 0);\n  (t = parseInt(t, 10) || 0), (t = r < 0 || Object.is(r, -0) ? -t : t);\n  return 60 * r + t;\n}\nfunction K(e) {\n  var t = Number(e);\n  if (\"boolean\" == typeof e || \"\" === e || Number.isNaN(t))\n    throw new a(`Invalid unit value ${e}`);\n  return t;\n}\nfunction X(e, t) {\n  const r = {};\n  for (const s in e) {\n    var n;\n    !q(e, s) || (null != (n = e[s]) && (r[t(s)] = K(n)));\n  }\n  return r;\n}\nfunction ee(e, t) {\n  var r = Math.trunc(Math.abs(e / 60)),\n    n = Math.trunc(Math.abs(e % 60)),\n    s = 0 <= e ? \"+\" : \"-\";\n  switch (t) {\n    case \"short\":\n      return `${s}${j(r, 2)}:${j(n, 2)}`;\n    case \"narrow\":\n      return `${s}${r}${0 < n ? `:${n}` : \"\"}`;\n    case \"techie\":\n      return `${s}${j(r, 2)}${j(n, 2)}`;\n    default:\n      throw new RangeError(\n        `Value format ${t} is out of range for property format`\n      );\n  }\n}\nfunction te(e) {\n  return (\n    (r = e),\n    [\"hour\", \"minute\", \"second\", \"millisecond\"].reduce(\n      (e, t) => ((e[t] = r[t]), e),\n      {}\n    )\n  );\n  var r;\n}\nvar re = /[A-Za-z_+-]{1,256}(:?\\/[A-Za-z_+-]{1,256}(\\/[A-Za-z_+-]{1,256})?)?/;\nconst ne = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\",\n  ],\n  se = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\",\n  ],\n  ie = [\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"];\nfunction ae(e) {\n  switch (e) {\n    case \"narrow\":\n      return [...ie];\n    case \"short\":\n      return [...se];\n    case \"long\":\n      return [...ne];\n    case \"numeric\":\n      return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"];\n    case \"2-digit\":\n      return [\n        \"01\",\n        \"02\",\n        \"03\",\n        \"04\",\n        \"05\",\n        \"06\",\n        \"07\",\n        \"08\",\n        \"09\",\n        \"10\",\n        \"11\",\n        \"12\",\n      ];\n    default:\n      return null;\n  }\n}\nconst oe = [\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\",\n  ],\n  ue = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n  le = [\"M\", \"T\", \"W\", \"T\", \"F\", \"S\", \"S\"];\nfunction ce(e) {\n  switch (e) {\n    case \"narrow\":\n      return [...le];\n    case \"short\":\n      return [...ue];\n    case \"long\":\n      return [...oe];\n    case \"numeric\":\n      return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"];\n    default:\n      return null;\n  }\n}\nconst he = [\"AM\", \"PM\"],\n  de = [\"Before Christ\", \"Anno Domini\"],\n  me = [\"BC\", \"AD\"],\n  fe = [\"B\", \"A\"];\nfunction ye(e) {\n  switch (e) {\n    case \"narrow\":\n      return [...fe];\n    case \"short\":\n      return [...me];\n    case \"long\":\n      return [...de];\n    default:\n      return null;\n  }\n}\nfunction ge(e, t) {\n  let r = \"\";\n  for (const n of e) n.literal ? (r += n.val) : (r += t(n.val));\n  return r;\n}\nconst we = {\n  D: c,\n  DD: h,\n  DDD: m,\n  DDDD: f,\n  t: y,\n  tt: g,\n  ttt: w,\n  tttt: p,\n  T: v,\n  TT: T,\n  TTT: S,\n  TTTT: O,\n  f: b,\n  ff: k,\n  fff: V,\n  ffff: x,\n  F: M,\n  FF: D,\n  FFF: I,\n  FFFF: C,\n};\nclass pe {\n  static create(e, t = {}) {\n    return new pe(e, t);\n  }\n  static parseFormat(t) {\n    let r = null,\n      n = \"\",\n      s = !1;\n    const i = [];\n    for (let e = 0; e < t.length; e++) {\n      var a = t.charAt(e);\n      \"'\" === a\n        ? (0 < n.length && i.push({ literal: s, val: n }),\n          (r = null),\n          (n = \"\"),\n          (s = !s))\n        : s || a === r\n        ? (n += a)\n        : (0 < n.length && i.push({ literal: !1, val: n }), (n = a), (r = a));\n    }\n    return 0 < n.length && i.push({ literal: s, val: n }), i;\n  }\n  static macroTokenToFormatOpts(e) {\n    return we[e];\n  }\n  constructor(e, t) {\n    (this.opts = t), (this.loc = e), (this.systemLoc = null);\n  }\n  formatWithSystemDefault(e, t) {\n    null === this.systemLoc && (this.systemLoc = this.loc.redefaultToSystem());\n    const r = this.systemLoc.dtFormatter(e, { ...this.opts, ...t });\n    return r.format();\n  }\n  formatDateTime(e, t = {}) {\n    const r = this.loc.dtFormatter(e, { ...this.opts, ...t });\n    return r.format();\n  }\n  formatDateTimeParts(e, t = {}) {\n    const r = this.loc.dtFormatter(e, { ...this.opts, ...t });\n    return r.formatToParts();\n  }\n  resolvedOptions(e, t = {}) {\n    const r = this.loc.dtFormatter(e, { ...this.opts, ...t });\n    return r.resolvedOptions();\n  }\n  num(e, t = 0) {\n    if (this.opts.forceSimple) return j(e, t);\n    const r = { ...this.opts };\n    return 0 < t && (r.padTo = t), this.loc.numberFormatter(r).format(e);\n  }\n  formatDateTimeFromString(r, e) {\n    const n = \"en\" === this.loc.listingMode(),\n      t = this.loc.outputCalendar && \"gregory\" !== this.loc.outputCalendar,\n      s = (e, t) => this.loc.extract(r, e, t),\n      i = (e) =>\n        r.isOffsetFixed && 0 === r.offset && e.allowZ\n          ? \"Z\"\n          : r.isValid\n          ? r.zone.formatOffset(r.ts, e.format)\n          : \"\",\n      a = () =>\n        n\n          ? (function (e) {\n              return he[e.hour < 12 ? 0 : 1];\n            })(r)\n          : s({ hour: \"numeric\", hourCycle: \"h12\" }, \"dayperiod\"),\n      o = (e, t) =>\n        n\n          ? (function (e, t) {\n              return ae(t)[e.month - 1];\n            })(r, e)\n          : s(t ? { month: e } : { month: e, day: \"numeric\" }, \"month\"),\n      u = (e, t) =>\n        n\n          ? (function (e, t) {\n              return ce(t)[e.weekday - 1];\n            })(r, e)\n          : s(\n              t\n                ? { weekday: e }\n                : { weekday: e, month: \"long\", day: \"numeric\" },\n              \"weekday\"\n            ),\n      l = (e) => {\n        var t = pe.macroTokenToFormatOpts(e);\n        return t ? this.formatWithSystemDefault(r, t) : e;\n      },\n      c = (e) =>\n        n\n          ? (function (e, t) {\n              return ye(t)[e.year < 0 ? 0 : 1];\n            })(r, e)\n          : s({ era: e }, \"era\");\n    return ge(pe.parseFormat(e), (e) => {\n      switch (e) {\n        case \"S\":\n          return this.num(r.millisecond);\n        case \"u\":\n        case \"SSS\":\n          return this.num(r.millisecond, 3);\n        case \"s\":\n          return this.num(r.second);\n        case \"ss\":\n          return this.num(r.second, 2);\n        case \"m\":\n          return this.num(r.minute);\n        case \"mm\":\n          return this.num(r.minute, 2);\n        case \"h\":\n          return this.num(r.hour % 12 == 0 ? 12 : r.hour % 12);\n        case \"hh\":\n          return this.num(r.hour % 12 == 0 ? 12 : r.hour % 12, 2);\n        case \"H\":\n          return this.num(r.hour);\n        case \"HH\":\n          return this.num(r.hour, 2);\n        case \"Z\":\n          return i({ format: \"narrow\", allowZ: this.opts.allowZ });\n        case \"ZZ\":\n          return i({ format: \"short\", allowZ: this.opts.allowZ });\n        case \"ZZZ\":\n          return i({ format: \"techie\", allowZ: this.opts.allowZ });\n        case \"ZZZZ\":\n          return r.zone.offsetName(r.ts, {\n            format: \"short\",\n            locale: this.loc.locale,\n          });\n        case \"ZZZZZ\":\n          return r.zone.offsetName(r.ts, {\n            format: \"long\",\n            locale: this.loc.locale,\n          });\n        case \"z\":\n          return r.zoneName;\n        case \"a\":\n          return a();\n        case \"d\":\n          return t ? s({ day: \"numeric\" }, \"day\") : this.num(r.day);\n        case \"dd\":\n          return t ? s({ day: \"2-digit\" }, \"day\") : this.num(r.day, 2);\n        case \"c\":\n          return this.num(r.weekday);\n        case \"ccc\":\n          return u(\"short\", !0);\n        case \"cccc\":\n          return u(\"long\", !0);\n        case \"ccccc\":\n          return u(\"narrow\", !0);\n        case \"E\":\n          return this.num(r.weekday);\n        case \"EEE\":\n          return u(\"short\", !1);\n        case \"EEEE\":\n          return u(\"long\", !1);\n        case \"EEEEE\":\n          return u(\"narrow\", !1);\n        case \"L\":\n          return t\n            ? s({ month: \"numeric\", day: \"numeric\" }, \"month\")\n            : this.num(r.month);\n        case \"LL\":\n          return t\n            ? s({ month: \"2-digit\", day: \"numeric\" }, \"month\")\n            : this.num(r.month, 2);\n        case \"LLL\":\n          return o(\"short\", !0);\n        case \"LLLL\":\n          return o(\"long\", !0);\n        case \"LLLLL\":\n          return o(\"narrow\", !0);\n        case \"M\":\n          return t ? s({ month: \"numeric\" }, \"month\") : this.num(r.month);\n        case \"MM\":\n          return t ? s({ month: \"2-digit\" }, \"month\") : this.num(r.month, 2);\n        case \"MMM\":\n          return o(\"short\", !1);\n        case \"MMMM\":\n          return o(\"long\", !1);\n        case \"MMMMM\":\n          return o(\"narrow\", !1);\n        case \"y\":\n          return t ? s({ year: \"numeric\" }, \"year\") : this.num(r.year);\n        case \"yy\":\n          return t\n            ? s({ year: \"2-digit\" }, \"year\")\n            : this.num(r.year.toString().slice(-2), 2);\n        case \"yyyy\":\n          return t ? s({ year: \"numeric\" }, \"year\") : this.num(r.year, 4);\n        case \"yyyyyy\":\n          return t ? s({ year: \"numeric\" }, \"year\") : this.num(r.year, 6);\n        case \"G\":\n          return c(\"short\");\n        case \"GG\":\n          return c(\"long\");\n        case \"GGGGG\":\n          return c(\"narrow\");\n        case \"kk\":\n          return this.num(r.weekYear.toString().slice(-2), 2);\n        case \"kkkk\":\n          return this.num(r.weekYear, 4);\n        case \"W\":\n          return this.num(r.weekNumber);\n        case \"WW\":\n          return this.num(r.weekNumber, 2);\n        case \"o\":\n          return this.num(r.ordinal);\n        case \"ooo\":\n          return this.num(r.ordinal, 3);\n        case \"q\":\n          return this.num(r.quarter);\n        case \"qq\":\n          return this.num(r.quarter, 2);\n        case \"X\":\n          return this.num(Math.floor(r.ts / 1e3));\n        case \"x\":\n          return this.num(r.ts);\n        default:\n          return l(e);\n      }\n    });\n  }\n  formatDurationFromString(e, t) {\n    const r = (e) => {\n        switch (e[0]) {\n          case \"S\":\n            return \"millisecond\";\n          case \"s\":\n            return \"second\";\n          case \"m\":\n            return \"minute\";\n          case \"h\":\n            return \"hour\";\n          case \"d\":\n            return \"day\";\n          case \"M\":\n            return \"month\";\n          case \"y\":\n            return \"year\";\n          default:\n            return null;\n        }\n      },\n      n = pe.parseFormat(t),\n      s = n.reduce((e, { literal: t, val: r }) => (t ? e : e.concat(r)), []),\n      i = e.shiftTo(...s.map(r).filter((e) => e));\n    return ge(\n      n,\n      ((a = i),\n      (e) => {\n        var t = r(e);\n        return t ? this.num(a.get(t), e.length) : e;\n      })\n    );\n    var a;\n  }\n}\nclass ve {\n  constructor(e, t) {\n    (this.reason = e), (this.explanation = t);\n  }\n  toMessage() {\n    return this.explanation\n      ? `${this.reason}: ${this.explanation}`\n      : this.reason;\n  }\n}\nclass Te {\n  get type() {\n    throw new o();\n  }\n  get name() {\n    throw new o();\n  }\n  get isUniversal() {\n    throw new o();\n  }\n  offsetName(e, t) {\n    throw new o();\n  }\n  formatOffset(e, t) {\n    throw new o();\n  }\n  offset(e) {\n    throw new o();\n  }\n  equals(e) {\n    throw new o();\n  }\n  get isValid() {\n    throw new o();\n  }\n}\nlet Se = null;\nclass Oe extends Te {\n  static get instance() {\n    return null === Se && (Se = new Oe()), Se;\n  }\n  get type() {\n    return \"system\";\n  }\n  get name() {\n    return new Intl.DateTimeFormat().resolvedOptions().timeZone;\n  }\n  get isUniversal() {\n    return !1;\n  }\n  offsetName(e, { format: t, locale: r }) {\n    return B(e, t, r);\n  }\n  formatOffset(e, t) {\n    return ee(this.offset(e), t);\n  }\n  offset(e) {\n    return -new Date(e).getTimezoneOffset();\n  }\n  equals(e) {\n    return \"system\" === e.type;\n  }\n  get isValid() {\n    return !0;\n  }\n}\nconst be = RegExp(`^${re.source}$`);\nlet Me = {};\nconst ke = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 };\nlet Ne = {};\nclass De extends Te {\n  static create(e) {\n    return Ne[e] || (Ne[e] = new De(e)), Ne[e];\n  }\n  static resetCache() {\n    (Ne = {}), (Me = {});\n  }\n  static isValidSpecifier(e) {\n    return !(!e || !e.match(be));\n  }\n  static isValidZone(e) {\n    try {\n      return new Intl.DateTimeFormat(\"en-US\", { timeZone: e }).format(), !0;\n    } catch (e) {\n      return !1;\n    }\n  }\n  static parseGMTOffset(e) {\n    if (e) {\n      e = e.match(/^Etc\\/GMT(0|[+-]\\d{1,2})$/i);\n      if (e) return -60 * parseInt(e[1]);\n    }\n    return null;\n  }\n  constructor(e) {\n    super(), (this.zoneName = e), (this.valid = De.isValidZone(e));\n  }\n  get type() {\n    return \"iana\";\n  }\n  get name() {\n    return this.zoneName;\n  }\n  get isUniversal() {\n    return !1;\n  }\n  offsetName(e, { format: t, locale: r }) {\n    return B(e, t, r, this.name);\n  }\n  formatOffset(e, t) {\n    return ee(this.offset(e), t);\n  }\n  offset(e) {\n    var t = new Date(e);\n    if (isNaN(t)) return NaN;\n    var r =\n        ((o = this.name),\n        Me[o] ||\n          (Me[o] = new Intl.DateTimeFormat(\"en-US\", {\n            hourCycle: \"h23\",\n            timeZone: o,\n            year: \"numeric\",\n            month: \"2-digit\",\n            day: \"2-digit\",\n            hour: \"2-digit\",\n            minute: \"2-digit\",\n            second: \"2-digit\",\n          })),\n        Me[o]),\n      [n, s, i, a, e, o] = (\n        r.formatToParts\n          ? function (e, t) {\n              const r = e.formatToParts(t),\n                n = [];\n              for (let e = 0; e < r.length; e++) {\n                var { type: s, value: i } = r[e],\n                  s = ke[s];\n                $(s) || (n[s] = parseInt(i, 10));\n              }\n              return n;\n            }\n          : function (e, t) {\n              var r = e.format(t).replace(/\\u200E/g, \"\"),\n                [, n, s, i, e, t, r] =\n                  /(\\d+)\\/(\\d+)\\/(\\d+),? (\\d+):(\\d+):(\\d+)/.exec(r);\n              return [i, n, s, e, t, r];\n            }\n      )(r, t),\n      r = +t,\n      t = r % 1e3;\n    return (\n      (J({\n        year: n,\n        month: s,\n        day: i,\n        hour: a,\n        minute: e,\n        second: o,\n        millisecond: 0,\n      }) -\n        (r -= 0 <= t ? t : 1e3 + t)) /\n      6e4\n    );\n  }\n  equals(e) {\n    return \"iana\" === e.type && e.name === this.name;\n  }\n  get isValid() {\n    return this.valid;\n  }\n}\nlet Ee = null;\nclass Ve extends Te {\n  static get utcInstance() {\n    return null === Ee && (Ee = new Ve(0)), Ee;\n  }\n  static instance(e) {\n    return 0 === e ? Ve.utcInstance : new Ve(e);\n  }\n  static parseSpecifier(e) {\n    if (e) {\n      e = e.match(/^utc(?:([+-]\\d{1,2})(?::(\\d{2}))?)?$/i);\n      if (e) return new Ve(Q(e[1], e[2]));\n    }\n    return null;\n  }\n  constructor(e) {\n    super(), (this.fixed = e);\n  }\n  get type() {\n    return \"fixed\";\n  }\n  get name() {\n    return 0 === this.fixed ? \"UTC\" : `UTC${ee(this.fixed, \"narrow\")}`;\n  }\n  offsetName() {\n    return this.name;\n  }\n  formatOffset(e, t) {\n    return ee(this.fixed, t);\n  }\n  get isUniversal() {\n    return !0;\n  }\n  offset() {\n    return this.fixed;\n  }\n  equals(e) {\n    return \"fixed\" === e.type && e.fixed === this.fixed;\n  }\n  get isValid() {\n    return !0;\n  }\n}\nclass Ie extends Te {\n  constructor(e) {\n    super(), (this.zoneName = e);\n  }\n  get type() {\n    return \"invalid\";\n  }\n  get name() {\n    return this.zoneName;\n  }\n  get isUniversal() {\n    return !1;\n  }\n  offsetName() {\n    return null;\n  }\n  formatOffset() {\n    return \"\";\n  }\n  offset() {\n    return NaN;\n  }\n  equals() {\n    return !1;\n  }\n  get isValid() {\n    return !1;\n  }\n}\nfunction xe(e, t) {\n  if ($(e) || null === e) return t;\n  if (e instanceof Te) return e;\n  if (\"string\" != typeof e)\n    return Z(e)\n      ? Ve.instance(e)\n      : \"object\" == typeof e && e.offset && \"number\" == typeof e.offset\n      ? e\n      : new Ie(e);\n  var r = e.toLowerCase();\n  return \"local\" === r || \"system\" === r\n    ? t\n    : \"utc\" === r || \"gmt\" === r\n    ? Ve.utcInstance\n    : null != (t = De.parseGMTOffset(e))\n    ? Ve.instance(t)\n    : De.isValidSpecifier(r)\n    ? De.create(e)\n    : Ve.parseSpecifier(r) || new Ie(e);\n}\nlet Ce = () => Date.now(),\n  $e = \"system\",\n  Ze = null,\n  Fe = null,\n  Le = null,\n  ze;\nclass qe {\n  static get now() {\n    return Ce;\n  }\n  static set now(e) {\n    Ce = e;\n  }\n  static set defaultZone(e) {\n    $e = e;\n  }\n  static get defaultZone() {\n    return xe($e, Oe.instance);\n  }\n  static get defaultLocale() {\n    return Ze;\n  }\n  static set defaultLocale(e) {\n    Ze = e;\n  }\n  static get defaultNumberingSystem() {\n    return Fe;\n  }\n  static set defaultNumberingSystem(e) {\n    Fe = e;\n  }\n  static get defaultOutputCalendar() {\n    return Le;\n  }\n  static set defaultOutputCalendar(e) {\n    Le = e;\n  }\n  static get throwOnInvalid() {\n    return ze;\n  }\n  static set throwOnInvalid(e) {\n    ze = e;\n  }\n  static resetCaches() {\n    Ye.resetCache(), De.resetCache();\n  }\n}\nlet Ae = {};\nfunction je(e, t = {}) {\n  var r = JSON.stringify([e, t]);\n  let n = Ae[r];\n  return n || ((n = new Intl.DateTimeFormat(e, t)), (Ae[r] = n)), n;\n}\nlet _e = {};\nlet Ue = {};\nlet He = null;\nfunction We(e, t, r, n, s) {\n  r = e.listingMode(r);\n  return \"error\" === r ? null : (\"en\" === r ? n : s)(t);\n}\nclass Re {\n  constructor(e, t, r) {\n    if (((this.padTo = r.padTo || 0), (this.floor = r.floor || !1), !t)) {\n      const n = { useGrouping: !1 };\n      0 < r.padTo && (n.minimumIntegerDigits = r.padTo),\n        (this.inf = (function (e, t = {}) {\n          var r = JSON.stringify([e, t]);\n          let n = _e[r];\n          return n || ((n = new Intl.NumberFormat(e, t)), (_e[r] = n)), n;\n        })(e, n));\n    }\n  }\n  format(e) {\n    if (this.inf) {\n      var t = this.floor ? Math.floor(e) : e;\n      return this.inf.format(t);\n    }\n    return j(this.floor ? Math.floor(e) : H(e, 3), this.padTo);\n  }\n}\nclass Pe {\n  constructor(e, t, r) {\n    this.opts = r;\n    let n;\n    var s, i;\n    e.zone.isUniversal\n      ? ((s = 0 <= (i = (e.offset / 60) * -1) ? `Etc/GMT+${i}` : `Etc/GMT${i}`),\n        (i = De.isValidZone(s)),\n        0 !== e.offset && i\n          ? ((n = s), (this.dt = e))\n          : ((n = \"UTC\"),\n            r.timeZoneName\n              ? (this.dt = e)\n              : (this.dt =\n                  0 === e.offset\n                    ? e\n                    : Wr.fromMillis(e.ts + 60 * e.offset * 1e3))))\n      : \"system\" === e.zone.type\n      ? (this.dt = e)\n      : ((this.dt = e), (n = e.zone.name));\n    const a = { ...this.opts };\n    n && (a.timeZone = n), (this.dtf = je(t, a));\n  }\n  format() {\n    return this.dtf.format(this.dt.toJSDate());\n  }\n  formatToParts() {\n    return this.dtf.formatToParts(this.dt.toJSDate());\n  }\n  resolvedOptions() {\n    return this.dtf.resolvedOptions();\n  }\n}\nclass Je {\n  constructor(e, t, r) {\n    (this.opts = { style: \"long\", ...r }),\n      !t &&\n        L() &&\n        (this.rtf = (function (e, t = {}) {\n          const { base: r, ...n } = t;\n          var s = JSON.stringify([e, n]);\n          let i = Ue[s];\n          return i || ((i = new Intl.RelativeTimeFormat(e, t)), (Ue[s] = i)), i;\n        })(e, r));\n  }\n  format(e, t) {\n    return this.rtf\n      ? this.rtf.format(e, t)\n      : (function (e, t, r = \"always\", n) {\n          var s = {\n              years: [\"year\", \"yr.\"],\n              quarters: [\"quarter\", \"qtr.\"],\n              months: [\"month\", \"mo.\"],\n              weeks: [\"week\", \"wk.\"],\n              days: [\"day\", \"day\", \"days\"],\n              hours: [\"hour\", \"hr.\"],\n              minutes: [\"minute\", \"min.\"],\n              seconds: [\"second\", \"sec.\"],\n            },\n            i = -1 === [\"hours\", \"minutes\", \"seconds\"].indexOf(e);\n          if (\"auto\" === r && i) {\n            var a = \"days\" === e;\n            switch (t) {\n              case 1:\n                return a ? \"tomorrow\" : `next ${s[e][0]}`;\n              case -1:\n                return a ? \"yesterday\" : `last ${s[e][0]}`;\n              case 0:\n                return a ? \"today\" : `this ${s[e][0]}`;\n            }\n          }\n          var o = Object.is(t, -0) || t < 0,\n            i = 1 === (r = Math.abs(t)),\n            t = s[e],\n            i = n ? (!i && t[2]) || t[1] : i ? s[e][0] : e;\n          return o ? `${r} ${i} ago` : `in ${r} ${i}`;\n        })(t, e, this.opts.numeric, \"long\" !== this.opts.style);\n  }\n  formatToParts(e, t) {\n    return this.rtf ? this.rtf.formatToParts(e, t) : [];\n  }\n}\nclass Ye {\n  static fromOpts(e) {\n    return Ye.create(\n      e.locale,\n      e.numberingSystem,\n      e.outputCalendar,\n      e.defaultToEN\n    );\n  }\n  static create(e, t, r, n = !1) {\n    (e = e || qe.defaultLocale),\n      (n =\n        e ||\n        (n\n          ? \"en-US\"\n          : He ||\n            ((He = new Intl.DateTimeFormat().resolvedOptions().locale), He))),\n      (t = t || qe.defaultNumberingSystem),\n      (r = r || qe.defaultOutputCalendar);\n    return new Ye(n, t, r, e);\n  }\n  static resetCache() {\n    (He = null), (Ae = {}), (_e = {}), (Ue = {});\n  }\n  static fromObject({ locale: e, numberingSystem: t, outputCalendar: r } = {}) {\n    return Ye.create(e, t, r);\n  }\n  constructor(e, t, r, n) {\n    var [s, i, e] = (function (e) {\n      if (-1 === (n = e.indexOf(\"-u-\"))) return [e];\n      {\n        let t;\n        var r = e.substring(0, n);\n        try {\n          t = je(e).resolvedOptions();\n        } catch (e) {\n          t = je(r).resolvedOptions();\n        }\n        var { numberingSystem: n, calendar: e } = t;\n        return [r, n, e];\n      }\n    })(e);\n    (this.locale = s),\n      (this.numberingSystem = t || i || null),\n      (this.outputCalendar = r || e || null),\n      (this.intl =\n        ((i = this.locale),\n        (r = this.numberingSystem),\n        ((e = this.outputCalendar) || r) &&\n          ((i += \"-u\"), e && (i += `-ca-${e}`), r && (i += `-nu-${r}`)),\n        i)),\n      (this.weekdaysCache = { format: {}, standalone: {} }),\n      (this.monthsCache = { format: {}, standalone: {} }),\n      (this.meridiemCache = null),\n      (this.eraCache = {}),\n      (this.specifiedLocale = n),\n      (this.fastNumbersCached = null);\n  }\n  get fastNumbers() {\n    var e;\n    return (\n      null == this.fastNumbersCached &&\n        (this.fastNumbersCached =\n          (!(e = this).numberingSystem || \"latn\" === e.numberingSystem) &&\n          (\"latn\" === e.numberingSystem ||\n            !e.locale ||\n            e.locale.startsWith(\"en\") ||\n            \"latn\" ===\n              new Intl.DateTimeFormat(e.intl).resolvedOptions()\n                .numberingSystem)),\n      this.fastNumbersCached\n    );\n  }\n  listingMode(e = 0) {\n    var t = this.isEnglish(),\n      r = !(\n        (null !== this.numberingSystem && \"latn\" !== this.numberingSystem) ||\n        (null !== this.outputCalendar && \"gregory\" !== this.outputCalendar)\n      );\n    return t && r ? \"en\" : \"intl\";\n  }\n  clone(e) {\n    return e && 0 !== Object.getOwnPropertyNames(e).length\n      ? Ye.create(\n          e.locale || this.specifiedLocale,\n          e.numberingSystem || this.numberingSystem,\n          e.outputCalendar || this.outputCalendar,\n          e.defaultToEN || !1\n        )\n      : this;\n  }\n  redefaultToEN(e = {}) {\n    return this.clone({ ...e, defaultToEN: !0 });\n  }\n  redefaultToSystem(e = {}) {\n    return this.clone({ ...e, defaultToEN: !1 });\n  }\n  months(r, n = !1, e = !0) {\n    return We(this, r, e, ae, () => {\n      const t = n ? { month: r, day: \"numeric\" } : { month: r },\n        e = n ? \"format\" : \"standalone\";\n      return (\n        this.monthsCache[e][r] ||\n          (this.monthsCache[e][r] = (function (t) {\n            const r = [];\n            for (let e = 1; e <= 12; e++) {\n              var n = Wr.utc(2016, e, 1);\n              r.push(t(n));\n            }\n            return r;\n          })((e) => this.extract(e, t, \"month\"))),\n        this.monthsCache[e][r]\n      );\n    });\n  }\n  weekdays(r, n = !1, e = !0) {\n    return We(this, r, e, ce, () => {\n      const t = n\n          ? { weekday: r, year: \"numeric\", month: \"long\", day: \"numeric\" }\n          : { weekday: r },\n        e = n ? \"format\" : \"standalone\";\n      return (\n        this.weekdaysCache[e][r] ||\n          (this.weekdaysCache[e][r] = (function (t) {\n            const r = [];\n            for (let e = 1; e <= 7; e++) {\n              var n = Wr.utc(2016, 11, 13 + e);\n              r.push(t(n));\n            }\n            return r;\n          })((e) => this.extract(e, t, \"weekday\"))),\n        this.weekdaysCache[e][r]\n      );\n    });\n  }\n  meridiems(e = !0) {\n    return We(\n      this,\n      void 0,\n      e,\n      () => he,\n      () => {\n        if (!this.meridiemCache) {\n          const t = { hour: \"numeric\", hourCycle: \"h12\" };\n          this.meridiemCache = [\n            Wr.utc(2016, 11, 13, 9),\n            Wr.utc(2016, 11, 13, 19),\n          ].map((e) => this.extract(e, t, \"dayperiod\"));\n        }\n        return this.meridiemCache;\n      }\n    );\n  }\n  eras(e, t = !0) {\n    return We(this, e, t, ye, () => {\n      const t = { era: e };\n      return (\n        this.eraCache[e] ||\n          (this.eraCache[e] = [Wr.utc(-40, 1, 1), Wr.utc(2017, 1, 1)].map((e) =>\n            this.extract(e, t, \"era\")\n          )),\n        this.eraCache[e]\n      );\n    });\n  }\n  extract(e, t, r) {\n    const n = this.dtFormatter(e, t),\n      s = n.formatToParts(),\n      i = s.find((e) => e.type.toLowerCase() === r);\n    return i ? i.value : null;\n  }\n  numberFormatter(e = {}) {\n    return new Re(this.intl, e.forceSimple || this.fastNumbers, e);\n  }\n  dtFormatter(e, t = {}) {\n    return new Pe(e, this.intl, t);\n  }\n  relFormatter(e = {}) {\n    return new Je(this.intl, this.isEnglish(), e);\n  }\n  isEnglish() {\n    return (\n      \"en\" === this.locale ||\n      \"en-us\" === this.locale.toLowerCase() ||\n      new Intl.DateTimeFormat(this.intl)\n        .resolvedOptions()\n        .locale.startsWith(\"en-us\")\n    );\n  }\n  equals(e) {\n    return (\n      this.locale === e.locale &&\n      this.numberingSystem === e.numberingSystem &&\n      this.outputCalendar === e.outputCalendar\n    );\n  }\n}\nfunction Ge(...e) {\n  e = e.reduce((e, t) => e + t.source, \"\");\n  return RegExp(`^${e}$`);\n}\nfunction Be(...e) {\n  return (i) =>\n    e\n      .reduce(\n        ([e, t, r], n) => {\n          var [s, n, r] = n(i, r);\n          return [{ ...e, ...s }, t || n, r];\n        },\n        [{}, null, 1]\n      )\n      .slice(0, 2);\n}\nfunction Qe(e, ...t) {\n  if (null == e) return [null, null];\n  for (var [r, n] of t) {\n    r = r.exec(e);\n    if (r) return n(r);\n  }\n  return [null, null];\n}\nfunction Ke(...s) {\n  return (e, t) => {\n    const r = {};\n    let n;\n    for (n = 0; n < s.length; n++) r[s[n]] = _(e[t + n]);\n    return [r, null, t + n];\n  };\n}\nvar Xe = /(?:(Z)|([+-]\\d\\d)(?::?(\\d\\d))?)/,\n  et = /(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/,\n  tt = RegExp(`${et.source}${Xe.source}?`),\n  u = RegExp(`(?:T${tt.source})?`),\n  t = Ke(\"weekYear\", \"weekNumber\", \"weekDay\"),\n  l = Ke(\"year\", \"ordinal\"),\n  Xe = RegExp(`${et.source} ?(?:${Xe.source}|(${re.source}))?`),\n  re = RegExp(`(?: ${Xe.source})?`);\nfunction rt(e, t, r) {\n  t = e[t];\n  return $(t) ? r : _(t);\n}\nfunction nt(e, t) {\n  return [\n    { year: rt(e, t), month: rt(e, t + 1, 1), day: rt(e, t + 2, 1) },\n    null,\n    t + 3,\n  ];\n}\nfunction st(e, t) {\n  return [\n    {\n      hours: rt(e, t, 0),\n      minutes: rt(e, t + 1, 0),\n      seconds: rt(e, t + 2, 0),\n      milliseconds: U(e[t + 3]),\n    },\n    null,\n    t + 4,\n  ];\n}\nfunction it(e, t) {\n  var r = !e[t] && !e[t + 1],\n    e = Q(e[t + 1], e[t + 2]);\n  return [{}, r ? null : Ve.instance(e), t + 3];\n}\nfunction at(e, t) {\n  return [{}, e[t] ? De.create(e[t]) : null, t + 1];\n}\nconst ot = RegExp(`^T?${et.source}$`),\n  ut =\n    /^-?P(?:(?:(-?\\d{1,9})Y)?(?:(-?\\d{1,9})M)?(?:(-?\\d{1,9})W)?(?:(-?\\d{1,9})D)?(?:T(?:(-?\\d{1,9})H)?(?:(-?\\d{1,9})M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,9}))?S)?)?)$/;\nfunction lt(e) {\n  var [t, r, n, s, i, a, o, u, l] = e;\n  const c = \"-\" === t[0];\n  (e = u && \"-\" === u[0]),\n    (t = (e, t = !1) => (void 0 !== e && (t || (e && c)) ? -e : e));\n  return [\n    {\n      years: t(_(r)),\n      months: t(_(n)),\n      weeks: t(_(s)),\n      days: t(_(i)),\n      hours: t(_(a)),\n      minutes: t(_(o)),\n      seconds: t(_(u), \"-0\" === u),\n      milliseconds: t(U(l), e),\n    },\n  ];\n}\nconst ct = {\n  GMT: 0,\n  EDT: -240,\n  EST: -300,\n  CDT: -300,\n  CST: -360,\n  MDT: -360,\n  MST: -420,\n  PDT: -420,\n  PST: -480,\n};\nfunction ht(e, t, r, n, s, i, a) {\n  const o = {\n    year: 2 === t.length ? G(_(t)) : _(t),\n    month: se.indexOf(r) + 1,\n    day: _(n),\n    hour: _(s),\n    minute: _(i),\n  };\n  return (\n    a && (o.second = _(a)),\n    e && (o.weekday = 3 < e.length ? oe.indexOf(e) + 1 : ue.indexOf(e) + 1),\n    o\n  );\n}\nconst dt =\n  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;\nfunction mt(e) {\n  var [, t, r, n, s, i, a, o, u, l, c, e] = e,\n    o = ht(t, s, n, r, i, a, o);\n  let h;\n  return (h = u ? ct[u] : l ? 0 : Q(c, e)), [o, new Ve(h)];\n}\nconst ft =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  yt =\n    /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  gt =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;\nfunction wt(e) {\n  var [, t, r, n, s, i, a, e] = e;\n  return [ht(t, s, n, r, i, a, e), Ve.utcInstance];\n}\nfunction pt(e) {\n  var [, t, r, n, s, i, a, e] = e;\n  return [ht(t, e, r, n, s, i, a), Ve.utcInstance];\n}\nconst vt = Ge(/([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/, u),\n  Tt = Ge(/(\\d{4})-?W(\\d\\d)(?:-?(\\d))?/, u),\n  St = Ge(/(\\d{4})-?(\\d{3})/, u),\n  Ot = Ge(tt),\n  bt = Be(nt, st, it),\n  Mt = Be(t, st, it),\n  kt = Be(l, st, it),\n  Nt = Be(st, it);\nconst Dt = Be(st);\nconst Et = Ge(/(\\d{4})-(\\d\\d)-(\\d\\d)/, re),\n  Vt = Ge(Xe),\n  It = Be(nt, st, it, at),\n  xt = Be(st, it, at);\nconst Ct = {\n    weeks: {\n      days: 7,\n      hours: 168,\n      minutes: 10080,\n      seconds: 604800,\n      milliseconds: 6048e5,\n    },\n    days: { hours: 24, minutes: 1440, seconds: 86400, milliseconds: 864e5 },\n    hours: { minutes: 60, seconds: 3600, milliseconds: 36e5 },\n    minutes: { seconds: 60, milliseconds: 6e4 },\n    seconds: { milliseconds: 1e3 },\n  },\n  $t = {\n    years: {\n      quarters: 4,\n      months: 12,\n      weeks: 52,\n      days: 365,\n      hours: 8760,\n      minutes: 525600,\n      seconds: 31536e3,\n      milliseconds: 31536e6,\n    },\n    quarters: {\n      months: 3,\n      weeks: 13,\n      days: 91,\n      hours: 2184,\n      minutes: 131040,\n      seconds: 7862400,\n      milliseconds: 78624e5,\n    },\n    months: {\n      weeks: 4,\n      days: 30,\n      hours: 720,\n      minutes: 43200,\n      seconds: 2592e3,\n      milliseconds: 2592e6,\n    },\n    ...Ct,\n  },\n  Zt = 365.2425,\n  Ft = 30.436875,\n  Lt = {\n    years: {\n      quarters: 4,\n      months: 12,\n      weeks: Zt / 7,\n      days: Zt,\n      hours: 24 * Zt,\n      minutes: 525949.2,\n      seconds: 525949.2 * 60,\n      milliseconds: 525949.2 * 60 * 1e3,\n    },\n    quarters: {\n      months: 3,\n      weeks: Zt / 28,\n      days: Zt / 4,\n      hours: (24 * Zt) / 4,\n      minutes: 131487.3,\n      seconds: (525949.2 * 60) / 4,\n      milliseconds: 7889237999.999999,\n    },\n    months: {\n      weeks: Ft / 7,\n      days: Ft,\n      hours: 24 * Ft,\n      minutes: 43829.1,\n      seconds: 2629746,\n      milliseconds: 2629746e3,\n    },\n    ...Ct,\n  },\n  zt = [\n    \"years\",\n    \"quarters\",\n    \"months\",\n    \"weeks\",\n    \"days\",\n    \"hours\",\n    \"minutes\",\n    \"seconds\",\n    \"milliseconds\",\n  ],\n  qt = zt.slice(0).reverse();\nfunction At(e, t, r = !1) {\n  e = {\n    values: r ? t.values : { ...e.values, ...(t.values || {}) },\n    loc: e.loc.clone(t.loc),\n    conversionAccuracy: t.conversionAccuracy || e.conversionAccuracy,\n  };\n  return new _t(e);\n}\nfunction jt(e, t, r, n, s) {\n  var i = e[s][r],\n    a = t[r] / i,\n    a =\n      !(Math.sign(a) === Math.sign(n[s])) && 0 !== n[s] && Math.abs(a) <= 1\n        ? (e = a) < 0\n          ? Math.floor(e)\n          : Math.ceil(e)\n        : Math.trunc(a);\n  (n[s] += a), (t[r] -= a * i);\n}\nclass _t {\n  constructor(e) {\n    var t = \"longterm\" === e.conversionAccuracy || !1;\n    (this.values = e.values),\n      (this.loc = e.loc || Ye.create()),\n      (this.conversionAccuracy = t ? \"longterm\" : \"casual\"),\n      (this.invalid = e.invalid || null),\n      (this.matrix = t ? Lt : $t),\n      (this.isLuxonDuration = !0);\n  }\n  static fromMillis(e, t) {\n    return _t.fromObject({ milliseconds: e }, t);\n  }\n  static fromObject(e, t = {}) {\n    if (null == e || \"object\" != typeof e)\n      throw new a(\n        `Duration.fromObject: argument expected to be an object, got ${\n          null === e ? \"null\" : typeof e\n        }`\n      );\n    return new _t({\n      values: X(e, _t.normalizeUnit),\n      loc: Ye.fromObject(t),\n      conversionAccuracy: t.conversionAccuracy,\n    });\n  }\n  static fromISO(e, t) {\n    var [r] = Qe(e, [ut, lt]);\n    return r\n      ? _t.fromObject(r, t)\n      : _t.invalid(\n          \"unparsable\",\n          `the input \"${e}\" can't be parsed as ISO 8601`\n        );\n  }\n  static fromISOTime(e, t) {\n    var [r] = Qe(e, [ot, Dt]);\n    return r\n      ? _t.fromObject(r, t)\n      : _t.invalid(\n          \"unparsable\",\n          `the input \"${e}\" can't be parsed as ISO 8601`\n        );\n  }\n  static invalid(e, t = null) {\n    if (!e) throw new a(\"need to specify a reason the Duration is invalid\");\n    t = e instanceof ve ? e : new ve(e, t);\n    if (qe.throwOnInvalid) throw new s(t);\n    return new _t({ invalid: t });\n  }\n  static normalizeUnit(e) {\n    var t = {\n      year: \"years\",\n      years: \"years\",\n      quarter: \"quarters\",\n      quarters: \"quarters\",\n      month: \"months\",\n      months: \"months\",\n      week: \"weeks\",\n      weeks: \"weeks\",\n      day: \"days\",\n      days: \"days\",\n      hour: \"hours\",\n      hours: \"hours\",\n      minute: \"minutes\",\n      minutes: \"minutes\",\n      second: \"seconds\",\n      seconds: \"seconds\",\n      millisecond: \"milliseconds\",\n      milliseconds: \"milliseconds\",\n    }[e && e.toLowerCase()];\n    if (!t) throw new i(e);\n    return t;\n  }\n  static isDuration(e) {\n    return (e && e.isLuxonDuration) || !1;\n  }\n  get locale() {\n    return this.isValid ? this.loc.locale : null;\n  }\n  get numberingSystem() {\n    return this.isValid ? this.loc.numberingSystem : null;\n  }\n  toFormat(e, t = {}) {\n    t = { ...t, floor: !1 !== t.round && !1 !== t.floor };\n    return this.isValid\n      ? pe.create(this.loc, t).formatDurationFromString(this, e)\n      : \"Invalid Duration\";\n  }\n  toObject() {\n    return this.isValid ? { ...this.values } : {};\n  }\n  toISO() {\n    if (!this.isValid) return null;\n    let e = \"P\";\n    return (\n      0 !== this.years && (e += this.years + \"Y\"),\n      (0 === this.months && 0 === this.quarters) ||\n        (e += this.months + 3 * this.quarters + \"M\"),\n      0 !== this.weeks && (e += this.weeks + \"W\"),\n      0 !== this.days && (e += this.days + \"D\"),\n      (0 === this.hours &&\n        0 === this.minutes &&\n        0 === this.seconds &&\n        0 === this.milliseconds) ||\n        (e += \"T\"),\n      0 !== this.hours && (e += this.hours + \"H\"),\n      0 !== this.minutes && (e += this.minutes + \"M\"),\n      (0 === this.seconds && 0 === this.milliseconds) ||\n        (e += H(this.seconds + this.milliseconds / 1e3, 3) + \"S\"),\n      \"P\" === e && (e += \"T0S\"),\n      e\n    );\n  }\n  toISOTime(e = {}) {\n    if (!this.isValid) return null;\n    var t = this.toMillis();\n    if (t < 0 || 864e5 <= t) return null;\n    e = {\n      suppressMilliseconds: !1,\n      suppressSeconds: !1,\n      includePrefix: !1,\n      format: \"extended\",\n      ...e,\n    };\n    const r = this.shiftTo(\"hours\", \"minutes\", \"seconds\", \"milliseconds\");\n    let n = \"basic\" === e.format ? \"hhmm\" : \"hh:mm\";\n    (e.suppressSeconds && 0 === r.seconds && 0 === r.milliseconds) ||\n      ((n += \"basic\" === e.format ? \"ss\" : \":ss\"),\n      (e.suppressMilliseconds && 0 === r.milliseconds) || (n += \".SSS\"));\n    let s = r.toFormat(n);\n    return e.includePrefix && (s = \"T\" + s), s;\n  }\n  toJSON() {\n    return this.toISO();\n  }\n  toString() {\n    return this.toISO();\n  }\n  toMillis() {\n    return this.as(\"milliseconds\");\n  }\n  valueOf() {\n    return this.toMillis();\n  }\n  plus(e) {\n    if (!this.isValid) return this;\n    const t = Ut(e),\n      r = {};\n    for (const n of zt)\n      (q(t.values, n) || q(this.values, n)) && (r[n] = t.get(n) + this.get(n));\n    return At(this, { values: r }, !0);\n  }\n  minus(e) {\n    if (!this.isValid) return this;\n    const t = Ut(e);\n    return this.plus(t.negate());\n  }\n  mapUnits(e) {\n    if (!this.isValid) return this;\n    const t = {};\n    for (const r of Object.keys(this.values)) t[r] = K(e(this.values[r], r));\n    return At(this, { values: t }, !0);\n  }\n  get(e) {\n    return this[_t.normalizeUnit(e)];\n  }\n  set(e) {\n    return this.isValid\n      ? At(this, { values: { ...this.values, ...X(e, _t.normalizeUnit) } })\n      : this;\n  }\n  reconfigure({ locale: e, numberingSystem: t, conversionAccuracy: r } = {}) {\n    const n = this.loc.clone({ locale: e, numberingSystem: t }),\n      s = { loc: n };\n    return r && (s.conversionAccuracy = r), At(this, s);\n  }\n  as(e) {\n    return this.isValid ? this.shiftTo(e).get(e) : NaN;\n  }\n  normalize() {\n    if (!this.isValid) return this;\n    var r,\n      n,\n      e = this.toObject();\n    return (\n      (r = this.matrix),\n      (n = e),\n      qt.reduce((e, t) => ($(n[t]) ? e : (e && jt(r, n, e, n, t), t)), null),\n      At(this, { values: e }, !0)\n    );\n  }\n  shiftTo(...e) {\n    if (!this.isValid) return this;\n    if (0 === e.length) return this;\n    e = e.map((e) => _t.normalizeUnit(e));\n    const t = {},\n      r = {},\n      n = this.toObject();\n    let s;\n    for (const a of zt)\n      if (0 <= e.indexOf(a)) {\n        s = a;\n        let e = 0;\n        for (const o in r) (e += this.matrix[o][a] * r[o]), (r[o] = 0);\n        Z(n[a]) && (e += n[a]);\n        var i = Math.trunc(e);\n        (t[a] = i), (r[a] = e - i);\n        for (const u in n)\n          zt.indexOf(u) > zt.indexOf(a) && jt(this.matrix, n, u, t, a);\n      } else Z(n[a]) && (r[a] = n[a]);\n    for (const l in r)\n      0 !== r[l] && (t[s] += l === s ? r[l] : r[l] / this.matrix[s][l]);\n    return At(this, { values: t }, !0).normalize();\n  }\n  negate() {\n    if (!this.isValid) return this;\n    const e = {};\n    for (const t of Object.keys(this.values)) e[t] = -this.values[t];\n    return At(this, { values: e }, !0);\n  }\n  get years() {\n    return this.isValid ? this.values.years || 0 : NaN;\n  }\n  get quarters() {\n    return this.isValid ? this.values.quarters || 0 : NaN;\n  }\n  get months() {\n    return this.isValid ? this.values.months || 0 : NaN;\n  }\n  get weeks() {\n    return this.isValid ? this.values.weeks || 0 : NaN;\n  }\n  get days() {\n    return this.isValid ? this.values.days || 0 : NaN;\n  }\n  get hours() {\n    return this.isValid ? this.values.hours || 0 : NaN;\n  }\n  get minutes() {\n    return this.isValid ? this.values.minutes || 0 : NaN;\n  }\n  get seconds() {\n    return this.isValid ? this.values.seconds || 0 : NaN;\n  }\n  get milliseconds() {\n    return this.isValid ? this.values.milliseconds || 0 : NaN;\n  }\n  get isValid() {\n    return null === this.invalid;\n  }\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n  equals(e) {\n    if (!this.isValid || !e.isValid) return !1;\n    if (!this.loc.equals(e.loc)) return !1;\n    for (const n of zt)\n      if (\n        ((t = this.values[n]),\n        (r = e.values[n]),\n        !(void 0 === t || 0 === t ? void 0 === r || 0 === r : t === r))\n      )\n        return !1;\n    var t, r;\n    return !0;\n  }\n}\nfunction Ut(e) {\n  if (Z(e)) return _t.fromMillis(e);\n  if (_t.isDuration(e)) return e;\n  if (\"object\" == typeof e) return _t.fromObject(e);\n  throw new a(`Unknown duration argument ${e} of type ${typeof e}`);\n}\nconst Ht = \"Invalid Interval\";\nclass Wt {\n  constructor(e) {\n    (this.s = e.start),\n      (this.e = e.end),\n      (this.invalid = e.invalid || null),\n      (this.isLuxonInterval = !0);\n  }\n  static invalid(e, t = null) {\n    if (!e) throw new a(\"need to specify a reason the Interval is invalid\");\n    t = e instanceof ve ? e : new ve(e, t);\n    if (qe.throwOnInvalid) throw new n(t);\n    return new Wt({ invalid: t });\n  }\n  static fromDateTimes(e, t) {\n    var r = Rr(e),\n      n = Rr(t),\n      e =\n        ((e = n),\n        (t = r) && t.isValid\n          ? e && e.isValid\n            ? e < t\n              ? Wt.invalid(\n                  \"end before start\",\n                  `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`\n                )\n              : null\n            : Wt.invalid(\"missing or invalid end\")\n          : Wt.invalid(\"missing or invalid start\"));\n    return null == e ? new Wt({ start: r, end: n }) : e;\n  }\n  static after(e, t) {\n    const r = Ut(t),\n      n = Rr(e);\n    return Wt.fromDateTimes(n, n.plus(r));\n  }\n  static before(e, t) {\n    const r = Ut(t),\n      n = Rr(e);\n    return Wt.fromDateTimes(n.minus(r), n);\n  }\n  static fromISO(e, s) {\n    var [i, a] = (e || \"\").split(\"/\", 2);\n    if (i && a) {\n      let e, t;\n      try {\n        (e = Wr.fromISO(i, s)), (t = e.isValid);\n      } catch (a) {\n        t = !1;\n      }\n      let r, n;\n      try {\n        (r = Wr.fromISO(a, s)), (n = r.isValid);\n      } catch (a) {\n        n = !1;\n      }\n      if (t && n) return Wt.fromDateTimes(e, r);\n      if (t) {\n        var o = _t.fromISO(a, s);\n        if (o.isValid) return Wt.after(e, o);\n      } else if (n) {\n        s = _t.fromISO(i, s);\n        if (s.isValid) return Wt.before(r, s);\n      }\n    }\n    return Wt.invalid(\n      \"unparsable\",\n      `the input \"${e}\" can't be parsed as ISO 8601`\n    );\n  }\n  static isInterval(e) {\n    return (e && e.isLuxonInterval) || !1;\n  }\n  get start() {\n    return this.isValid ? this.s : null;\n  }\n  get end() {\n    return this.isValid ? this.e : null;\n  }\n  get isValid() {\n    return null === this.invalidReason;\n  }\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n  length(e = \"milliseconds\") {\n    return this.isValid ? this.toDuration(e).get(e) : NaN;\n  }\n  count(e = \"milliseconds\") {\n    if (!this.isValid) return NaN;\n    const t = this.start.startOf(e),\n      r = this.end.startOf(e);\n    return Math.floor(r.diff(t, e).get(e)) + 1;\n  }\n  hasSame(e) {\n    return (\n      !!this.isValid && (this.isEmpty() || this.e.minus(1).hasSame(this.s, e))\n    );\n  }\n  isEmpty() {\n    return this.s.valueOf() === this.e.valueOf();\n  }\n  isAfter(e) {\n    return !!this.isValid && this.s > e;\n  }\n  isBefore(e) {\n    return !!this.isValid && this.e <= e;\n  }\n  contains(e) {\n    return !!this.isValid && this.s <= e && this.e > e;\n  }\n  set({ start: e, end: t } = {}) {\n    return this.isValid ? Wt.fromDateTimes(e || this.s, t || this.e) : this;\n  }\n  splitAt(...e) {\n    if (!this.isValid) return [];\n    const t = e\n        .map(Rr)\n        .filter((e) => this.contains(e))\n        .sort(),\n      r = [];\n    let { s: n } = this,\n      s = 0;\n    for (; n < this.e; ) {\n      var i = t[s] || this.e,\n        i = +i > +this.e ? this.e : i;\n      r.push(Wt.fromDateTimes(n, i)), (n = i), (s += 1);\n    }\n    return r;\n  }\n  splitBy(e) {\n    const t = Ut(e);\n    if (!this.isValid || !t.isValid || 0 === t.as(\"milliseconds\")) return [];\n    let { s: r } = this,\n      n = 1,\n      s;\n    const i = [];\n    for (; r < this.e; ) {\n      var a = this.start.plus(t.mapUnits((e) => e * n));\n      (s = +a > +this.e ? this.e : a),\n        i.push(Wt.fromDateTimes(r, s)),\n        (r = s),\n        (n += 1);\n    }\n    return i;\n  }\n  divideEqually(e) {\n    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];\n  }\n  overlaps(e) {\n    return this.e > e.s && this.s < e.e;\n  }\n  abutsStart(e) {\n    return !!this.isValid && +this.e == +e.s;\n  }\n  abutsEnd(e) {\n    return !!this.isValid && +e.e == +this.s;\n  }\n  engulfs(e) {\n    return !!this.isValid && this.s <= e.s && this.e >= e.e;\n  }\n  equals(e) {\n    return (\n      !(!this.isValid || !e.isValid) && this.s.equals(e.s) && this.e.equals(e.e)\n    );\n  }\n  intersection(e) {\n    if (!this.isValid) return this;\n    var t = (this.s > e.s ? this : e).s,\n      e = (this.e < e.e ? this : e).e;\n    return e <= t ? null : Wt.fromDateTimes(t, e);\n  }\n  union(e) {\n    if (!this.isValid) return this;\n    var t = (this.s < e.s ? this : e).s,\n      e = (this.e > e.e ? this : e).e;\n    return Wt.fromDateTimes(t, e);\n  }\n  static merge(e) {\n    const [t, r] = e\n      .sort((e, t) => e.s - t.s)\n      .reduce(\n        ([e, t], r) =>\n          t\n            ? t.overlaps(r) || t.abutsStart(r)\n              ? [e, t.union(r)]\n              : [e.concat([t]), r]\n            : [e, r],\n        [[], null]\n      );\n    return r && t.push(r), t;\n  }\n  static xor(e) {\n    let t = null,\n      r = 0;\n    const n = [],\n      s = e.map((e) => [\n        { time: e.s, type: \"s\" },\n        { time: e.e, type: \"e\" },\n      ]),\n      i = Array.prototype.concat(...s),\n      a = i.sort((e, t) => e.time - t.time);\n    for (const o of a)\n      (r += \"s\" === o.type ? 1 : -1),\n        (t =\n          1 === r\n            ? o.time\n            : (t && +t != +o.time && n.push(Wt.fromDateTimes(t, o.time)),\n              null));\n    return Wt.merge(n);\n  }\n  difference(...e) {\n    return Wt.xor([this].concat(e))\n      .map((e) => this.intersection(e))\n      .filter((e) => e && !e.isEmpty());\n  }\n  toString() {\n    return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : Ht;\n  }\n  toISO(e) {\n    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : Ht;\n  }\n  toISODate() {\n    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : Ht;\n  }\n  toISOTime(e) {\n    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : Ht;\n  }\n  toFormat(e, { separator: t = \" – \" } = {}) {\n    return this.isValid ? `${this.s.toFormat(e)}${t}${this.e.toFormat(e)}` : Ht;\n  }\n  toDuration(e, t) {\n    return this.isValid\n      ? this.e.diff(this.s, e, t)\n      : _t.invalid(this.invalidReason);\n  }\n  mapEndpoints(e) {\n    return Wt.fromDateTimes(e(this.s), e(this.e));\n  }\n}\nclass Rt {\n  static hasDST(e = qe.defaultZone) {\n    const t = Wr.now().setZone(e).set({ month: 12 });\n    return !e.isUniversal && t.offset !== t.set({ month: 6 }).offset;\n  }\n  static isValidIANAZone(e) {\n    return De.isValidSpecifier(e) && De.isValidZone(e);\n  }\n  static normalizeZone(e) {\n    return xe(e, qe.defaultZone);\n  }\n  static months(\n    e = \"long\",\n    {\n      locale: t = null,\n      numberingSystem: r = null,\n      locObj: n = null,\n      outputCalendar: s = \"gregory\",\n    } = {}\n  ) {\n    return (n || Ye.create(t, r, s)).months(e);\n  }\n  static monthsFormat(\n    e = \"long\",\n    {\n      locale: t = null,\n      numberingSystem: r = null,\n      locObj: n = null,\n      outputCalendar: s = \"gregory\",\n    } = {}\n  ) {\n    return (n || Ye.create(t, r, s)).months(e, !0);\n  }\n  static weekdays(\n    e = \"long\",\n    { locale: t = null, numberingSystem: r = null, locObj: n = null } = {}\n  ) {\n    return (n || Ye.create(t, r, null)).weekdays(e);\n  }\n  static weekdaysFormat(\n    e = \"long\",\n    { locale: t = null, numberingSystem: r = null, locObj: n = null } = {}\n  ) {\n    return (n || Ye.create(t, r, null)).weekdays(e, !0);\n  }\n  static meridiems({ locale: e = null } = {}) {\n    return Ye.create(e).meridiems();\n  }\n  static eras(e = \"short\", { locale: t = null } = {}) {\n    return Ye.create(t, null, \"gregory\").eras(e);\n  }\n  static features() {\n    return { relative: L() };\n  }\n}\nfunction Pt(e, t) {\n  var r = (e) => e.toUTC(0, { keepLocalTime: !0 }).startOf(\"day\").valueOf(),\n    e = r(t) - r(e);\n  return Math.floor(_t.fromMillis(e).as(\"days\"));\n}\nfunction Jt(e, t, r, n) {\n  let [s, i, a, o] = (function (t, r, e) {\n    var n, s;\n    const i = {};\n    let a, o;\n    for ([n, s] of [\n      [\"years\", (e, t) => t.year - e.year],\n      [\"quarters\", (e, t) => t.quarter - e.quarter],\n      [\"months\", (e, t) => t.month - e.month + 12 * (t.year - e.year)],\n      [\n        \"weeks\",\n        (e, t) => {\n          t = Pt(e, t);\n          return (t - (t % 7)) / 7;\n        },\n      ],\n      [\"days\", Pt],\n    ])\n      if (0 <= e.indexOf(n)) {\n        a = n;\n        let e = s(t, r);\n        (o = t.plus({ [n]: e })),\n          o > r ? ((t = t.plus({ [n]: e - 1 })), --e) : (t = o),\n          (i[n] = e);\n      }\n    return [t, i, o, a];\n  })(e, t, r);\n  (e = t - s),\n    (r = r.filter(\n      (e) => 0 <= [\"hours\", \"minutes\", \"seconds\", \"milliseconds\"].indexOf(e)\n    ));\n  0 === r.length &&\n    (a < t && (a = s.plus({ [o]: 1 })),\n    a !== s && (i[o] = (i[o] || 0) + e / (a - s)));\n  t = _t.fromObject(i, n);\n  return 0 < r.length\n    ? _t\n        .fromMillis(e, n)\n        .shiftTo(...r)\n        .plus(t)\n    : t;\n}\nconst Yt = {\n    arab: \"[٠-٩]\",\n    arabext: \"[۰-۹]\",\n    bali: \"[᭐-᭙]\",\n    beng: \"[০-৯]\",\n    deva: \"[०-९]\",\n    fullwide: \"[０-９]\",\n    gujr: \"[૦-૯]\",\n    hanidec: \"[〇|一|二|三|四|五|六|七|八|九]\",\n    khmr: \"[០-៩]\",\n    knda: \"[೦-೯]\",\n    laoo: \"[໐-໙]\",\n    limb: \"[᥆-᥏]\",\n    mlym: \"[൦-൯]\",\n    mong: \"[᠐-᠙]\",\n    mymr: \"[၀-၉]\",\n    orya: \"[୦-୯]\",\n    tamldec: \"[௦-௯]\",\n    telu: \"[౦-౯]\",\n    thai: \"[๐-๙]\",\n    tibt: \"[༠-༩]\",\n    latn: \"\\\\d\",\n  },\n  Gt = {\n    arab: [1632, 1641],\n    arabext: [1776, 1785],\n    bali: [6992, 7001],\n    beng: [2534, 2543],\n    deva: [2406, 2415],\n    fullwide: [65296, 65303],\n    gujr: [2790, 2799],\n    khmr: [6112, 6121],\n    knda: [3302, 3311],\n    laoo: [3792, 3801],\n    limb: [6470, 6479],\n    mlym: [3430, 3439],\n    mong: [6160, 6169],\n    mymr: [4160, 4169],\n    orya: [2918, 2927],\n    tamldec: [3046, 3055],\n    telu: [3174, 3183],\n    thai: [3664, 3673],\n    tibt: [3872, 3881],\n  },\n  Bt = Yt.hanidec.replace(/[\\[|\\]]/g, \"\").split(\"\");\nfunction Qt({ numberingSystem: e }, t = \"\") {\n  return new RegExp(`${Yt[e || \"latn\"]}${t}`);\n}\nconst Kt = \"missing Intl.DateTimeFormat.formatToParts support\";\nfunction Xt(e, t = (e) => e) {\n  return {\n    regex: e,\n    deser: ([e]) =>\n      t(\n        (function (t) {\n          let r = parseInt(t, 10);\n          if (isNaN(r)) {\n            r = \"\";\n            for (let e = 0; e < t.length; e++) {\n              var n = t.charCodeAt(e);\n              if (-1 !== t[e].search(Yt.hanidec)) r += Bt.indexOf(t[e]);\n              else\n                for (const a in Gt) {\n                  var [s, i] = Gt[a];\n                  s <= n && n <= i && (r += n - s);\n                }\n            }\n            return parseInt(r, 10);\n          }\n          return r;\n        })(e)\n      ),\n  };\n}\nconst er = `( |${String.fromCharCode(160)})`,\n  tr = new RegExp(er, \"g\");\nfunction rr(e) {\n  return e.replace(/\\./g, \"\\\\.?\").replace(tr, er);\n}\nfunction nr(e) {\n  return e.replace(/\\./g, \"\").replace(tr, \" \").toLowerCase();\n}\nfunction sr(e, r) {\n  return null === e\n    ? null\n    : {\n        regex: RegExp(e.map(rr).join(\"|\")),\n        deser: ([t]) => e.findIndex((e) => nr(t) === nr(e)) + r,\n      };\n}\nfunction ir(e, t) {\n  return { regex: e, deser: ([, e, t]) => Q(e, t), groups: t };\n}\nfunction ar(e) {\n  return { regex: e, deser: ([e]) => e };\n}\nconst or = {\n  year: { \"2-digit\": \"yy\", numeric: \"yyyyy\" },\n  month: { numeric: \"M\", \"2-digit\": \"MM\", short: \"MMM\", long: \"MMMM\" },\n  day: { numeric: \"d\", \"2-digit\": \"dd\" },\n  weekday: { short: \"EEE\", long: \"EEEE\" },\n  dayperiod: \"a\",\n  dayPeriod: \"a\",\n  hour: { numeric: \"h\", \"2-digit\": \"hh\" },\n  minute: { numeric: \"m\", \"2-digit\": \"mm\" },\n  second: { numeric: \"s\", \"2-digit\": \"ss\" },\n};\nlet ur = null;\nfunction lr(e, t) {\n  if (e.literal) return e;\n  const r = pe.macroTokenToFormatOpts(e.val);\n  if (!r) return e;\n  const n = pe.create(t, r),\n    s = n.formatDateTimeParts(((ur = ur || Wr.fromMillis(1555555555555)), ur)),\n    i = s.map((e) =>\n      (function (e, t) {\n        var { type: r, value: e } = e;\n        if (\"literal\" === r) return { literal: !0, val: e };\n        t = t[r];\n        let n = or[r];\n        return (\n          \"object\" == typeof n && (n = n[t]),\n          n ? { literal: !1, val: n } : void 0\n        );\n      })(e, r)\n    );\n  return i.includes(void 0) ? e : i;\n}\nfunction cr(t, e, r) {\n  const n =\n      ((l = pe.parseFormat(r)),\n      (a = t),\n      Array.prototype.concat(...l.map((e) => lr(e, a)))),\n    s = n.map((e) =>\n      (function (t, r) {\n        const n = Qt(r),\n          s = Qt(r, \"{2}\"),\n          i = Qt(r, \"{3}\"),\n          a = Qt(r, \"{4}\"),\n          o = Qt(r, \"{6}\"),\n          u = Qt(r, \"{1,2}\"),\n          l = Qt(r, \"{1,3}\"),\n          c = Qt(r, \"{1,6}\"),\n          h = Qt(r, \"{1,9}\"),\n          d = Qt(r, \"{2,4}\"),\n          m = Qt(r, \"{4,6}\"),\n          f = (e) => ({\n            regex: RegExp(e.val.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\")),\n            deser: ([e]) => e,\n            literal: !0,\n          }),\n          e = ((e) => {\n            if (t.literal) return f(e);\n            switch (e.val) {\n              case \"G\":\n                return sr(r.eras(\"short\", !1), 0);\n              case \"GG\":\n                return sr(r.eras(\"long\", !1), 0);\n              case \"y\":\n                return Xt(c);\n              case \"yy\":\n                return Xt(d, G);\n              case \"yyyy\":\n                return Xt(a);\n              case \"yyyyy\":\n                return Xt(m);\n              case \"yyyyyy\":\n                return Xt(o);\n              case \"M\":\n                return Xt(u);\n              case \"MM\":\n                return Xt(s);\n              case \"MMM\":\n                return sr(r.months(\"short\", !0, !1), 1);\n              case \"MMMM\":\n                return sr(r.months(\"long\", !0, !1), 1);\n              case \"L\":\n                return Xt(u);\n              case \"LL\":\n                return Xt(s);\n              case \"LLL\":\n                return sr(r.months(\"short\", !1, !1), 1);\n              case \"LLLL\":\n                return sr(r.months(\"long\", !1, !1), 1);\n              case \"d\":\n                return Xt(u);\n              case \"dd\":\n                return Xt(s);\n              case \"o\":\n                return Xt(l);\n              case \"ooo\":\n                return Xt(i);\n              case \"HH\":\n                return Xt(s);\n              case \"H\":\n                return Xt(u);\n              case \"hh\":\n                return Xt(s);\n              case \"h\":\n                return Xt(u);\n              case \"mm\":\n                return Xt(s);\n              case \"m\":\n              case \"q\":\n                return Xt(u);\n              case \"qq\":\n                return Xt(s);\n              case \"s\":\n                return Xt(u);\n              case \"ss\":\n                return Xt(s);\n              case \"S\":\n                return Xt(l);\n              case \"SSS\":\n                return Xt(i);\n              case \"u\":\n                return ar(h);\n              case \"a\":\n                return sr(r.meridiems(), 0);\n              case \"kkkk\":\n                return Xt(a);\n              case \"kk\":\n                return Xt(d, G);\n              case \"W\":\n                return Xt(u);\n              case \"WW\":\n                return Xt(s);\n              case \"E\":\n              case \"c\":\n                return Xt(n);\n              case \"EEE\":\n                return sr(r.weekdays(\"short\", !1, !1), 1);\n              case \"EEEE\":\n                return sr(r.weekdays(\"long\", !1, !1), 1);\n              case \"ccc\":\n                return sr(r.weekdays(\"short\", !0, !1), 1);\n              case \"cccc\":\n                return sr(r.weekdays(\"long\", !0, !1), 1);\n              case \"Z\":\n              case \"ZZ\":\n                return ir(\n                  new RegExp(`([+-]${u.source})(?::(${s.source}))?`),\n                  2\n                );\n              case \"ZZZ\":\n                return ir(new RegExp(`([+-]${u.source})(${s.source})?`), 2);\n              case \"z\":\n                return ar(/[a-z_+-/]{1,256}?/i);\n              default:\n                return f(e);\n            }\n          })(t) || { invalidReason: Kt };\n        return (e.token = t), e;\n      })(e, t)\n    ),\n    i = s.find((e) => e.invalidReason);\n  var a;\n  if (i) return { input: e, tokens: n, invalidReason: i.invalidReason };\n  var [o, u] = [\n      `^${(c = s)\n        .map((e) => e.regex)\n        .reduce((e, t) => `${e}(${t.source})`, \"\")}$`,\n      c,\n    ],\n    r = RegExp(o, \"i\"),\n    [l, c] = (function (e, t, r) {\n      const n = e.match(t);\n      if (n) {\n        const s = {};\n        let e = 1;\n        for (const i in r)\n          if (q(r, i)) {\n            const a = r[i],\n              o = a.groups ? a.groups + 1 : 1;\n            !a.literal &&\n              a.token &&\n              (s[a.token.val[0]] = a.deser(n.slice(e, e + o))),\n              (e += o);\n          }\n        return [n, s];\n      }\n      return [n, {}];\n    })(e, r, u),\n    [o, u] = c\n      ? (function (n) {\n          let e;\n          return (\n            (e = $(n.Z) ? ($(n.z) ? null : De.create(n.z)) : new Ve(n.Z)),\n            $(n.q) || (n.M = 3 * (n.q - 1) + 1),\n            $(n.h) ||\n              (n.h < 12 && 1 === n.a\n                ? (n.h += 12)\n                : 12 === n.h && 0 === n.a && (n.h = 0)),\n            0 === n.G && n.y && (n.y = -n.y),\n            $(n.u) || (n.S = U(n.u)),\n            [\n              Object.keys(n).reduce((e, t) => {\n                var r = ((e) => {\n                  switch (e) {\n                    case \"S\":\n                      return \"millisecond\";\n                    case \"s\":\n                      return \"second\";\n                    case \"m\":\n                      return \"minute\";\n                    case \"h\":\n                    case \"H\":\n                      return \"hour\";\n                    case \"d\":\n                      return \"day\";\n                    case \"o\":\n                      return \"ordinal\";\n                    case \"L\":\n                    case \"M\":\n                      return \"month\";\n                    case \"y\":\n                      return \"year\";\n                    case \"E\":\n                    case \"c\":\n                      return \"weekday\";\n                    case \"W\":\n                      return \"weekNumber\";\n                    case \"k\":\n                      return \"weekYear\";\n                    case \"q\":\n                      return \"quarter\";\n                    default:\n                      return null;\n                  }\n                })(t);\n                return r && (e[r] = n[t]), e;\n              }, {}),\n              e,\n            ]\n          );\n        })(c)\n      : [null, null];\n  if (q(c, \"a\") && q(c, \"H\"))\n    throw new N(\"Can't include meridiem when specifying 24-hour format\");\n  return {\n    input: e,\n    tokens: n,\n    regex: r,\n    rawMatches: l,\n    matches: c,\n    result: o,\n    zone: u,\n  };\n}\nconst hr = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n  dr = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];\nfunction mr(e, t) {\n  return new ve(\n    \"unit out of range\",\n    `you specified ${t} (of type ${typeof t}) as a ${e}, which is invalid`\n  );\n}\nfunction fr(e, t, r) {\n  r = new Date(Date.UTC(e, t - 1, r)).getUTCDay();\n  return 0 === r ? 7 : r;\n}\nfunction yr(e, t, r) {\n  return r + (W(e) ? dr : hr)[t - 1];\n}\nfunction gr(e, t) {\n  const r = W(e) ? dr : hr,\n    n = r.findIndex((e) => e < t),\n    s = t - r[n];\n  return { month: n + 1, day: s };\n}\nfunction wr(e) {\n  var { year: t, month: r, day: n } = e,\n    s = yr(t, r, n),\n    n = fr(t, r, n);\n  let i = Math.floor((s - n + 10) / 7),\n    a;\n  return (\n    i < 1\n      ? ((a = t - 1), (i = Y(a)))\n      : i > Y(t)\n      ? ((a = t + 1), (i = 1))\n      : (a = t),\n    { weekYear: a, weekNumber: i, weekday: n, ...te(e) }\n  );\n}\nfunction pr(e) {\n  var { weekYear: t, weekNumber: r, weekday: n } = e,\n    s = fr(t, 1, 4),\n    i = R(t);\n  let a = 7 * r + n - s - 3,\n    o;\n  a < 1\n    ? ((o = t - 1), (a += R(o)))\n    : a > i\n    ? ((o = t + 1), (a -= R(t)))\n    : (o = t);\n  var { month: i, day: t } = gr(o, a);\n  return { year: o, month: i, day: t, ...te(e) };\n}\nfunction vr(e) {\n  var { year: t, month: r, day: n } = e;\n  return { year: t, ordinal: yr(t, r, n), ...te(e) };\n}\nfunction Tr(e) {\n  var { year: t, ordinal: r } = e,\n    { month: n, day: r } = gr(t, r);\n  return { year: t, month: n, day: r, ...te(e) };\n}\nfunction Sr(e) {\n  var t = F(e.year),\n    r = A(e.month, 1, 12),\n    n = A(e.day, 1, P(e.year, e.month));\n  return t\n    ? r\n      ? !n && mr(\"day\", e.day)\n      : mr(\"month\", e.month)\n    : mr(\"year\", e.year);\n}\nfunction Or(e) {\n  var { hour: t, minute: r, second: n, millisecond: s } = e,\n    i = A(t, 0, 23) || (24 === t && 0 === r && 0 === n && 0 === s),\n    a = A(r, 0, 59),\n    o = A(n, 0, 59),\n    e = A(s, 0, 999);\n  return i\n    ? a\n      ? o\n        ? !e && mr(\"millisecond\", s)\n        : mr(\"second\", n)\n      : mr(\"minute\", r)\n    : mr(\"hour\", t);\n}\nconst br = \"Invalid DateTime\";\nfunction Mr(e) {\n  return new ve(\"unsupported zone\", `the zone \"${e.name}\" is not supported`);\n}\nfunction kr(e) {\n  return null === e.weekData && (e.weekData = wr(e.c)), e.weekData;\n}\nfunction Nr(e, t) {\n  e = {\n    ts: e.ts,\n    zone: e.zone,\n    c: e.c,\n    o: e.o,\n    loc: e.loc,\n    invalid: e.invalid,\n  };\n  return new Wr({ ...e, ...t, old: e });\n}\nfunction Dr(e, t, r) {\n  let n = e - 60 * t * 1e3;\n  var s = r.offset(n);\n  if (t === s) return [n, t];\n  n -= 60 * (s - t) * 1e3;\n  r = r.offset(n);\n  return s === r ? [n, s] : [e - 60 * Math.min(s, r) * 1e3, Math.max(s, r)];\n}\nfunction Er(e, t) {\n  e += 60 * t * 1e3;\n  const r = new Date(e);\n  return {\n    year: r.getUTCFullYear(),\n    month: r.getUTCMonth() + 1,\n    day: r.getUTCDate(),\n    hour: r.getUTCHours(),\n    minute: r.getUTCMinutes(),\n    second: r.getUTCSeconds(),\n    millisecond: r.getUTCMilliseconds(),\n  };\n}\nfunction Vr(e, t, r) {\n  return Dr(J(e), t, r);\n}\nfunction Ir(e, t) {\n  var r = e.o,\n    n = e.c.year + Math.trunc(t.years),\n    s = e.c.month + Math.trunc(t.months) + 3 * Math.trunc(t.quarters),\n    s = {\n      ...e.c,\n      year: n,\n      month: s,\n      day:\n        Math.min(e.c.day, P(n, s)) +\n        Math.trunc(t.days) +\n        7 * Math.trunc(t.weeks),\n    },\n    t = _t\n      .fromObject({\n        years: t.years - Math.trunc(t.years),\n        quarters: t.quarters - Math.trunc(t.quarters),\n        months: t.months - Math.trunc(t.months),\n        weeks: t.weeks - Math.trunc(t.weeks),\n        days: t.days - Math.trunc(t.days),\n        hours: t.hours,\n        minutes: t.minutes,\n        seconds: t.seconds,\n        milliseconds: t.milliseconds,\n      })\n      .as(\"milliseconds\");\n  let [i, a] = Dr(J(s), r, e.zone);\n  return 0 !== t && ((i += t), (a = e.zone.offset(i))), { ts: i, o: a };\n}\nfunction xr(e, t, r, n, s) {\n  var { setZone: i, zone: a } = r;\n  if (e && 0 !== Object.keys(e).length) {\n    const o = t || a,\n      u = Wr.fromObject(e, { ...r, zone: o });\n    return i ? u : u.setZone(a);\n  }\n  return Wr.invalid(\n    new ve(\"unparsable\", `the input \"${s}\" can't be parsed as ${n}`)\n  );\n}\nfunction Cr(e, t, r = !0) {\n  return e.isValid\n    ? pe\n        .create(Ye.create(\"en-US\"), { allowZ: r, forceSimple: !0 })\n        .formatDateTimeFromString(e, t)\n    : null;\n}\nfunction $r(\n  e,\n  {\n    suppressSeconds: t = !1,\n    suppressMilliseconds: r = !1,\n    includeOffset: n,\n    includePrefix: s = !1,\n    includeZone: i = !1,\n    spaceZone: a = !1,\n    format: o = \"extended\",\n  }\n) {\n  let u = \"basic\" === o ? \"HHmm\" : \"HH:mm\";\n  (t && 0 === e.second && 0 === e.millisecond) ||\n    ((u += \"basic\" === o ? \"ss\" : \":ss\"),\n    (r && 0 === e.millisecond) || (u += \".SSS\")),\n    (i || n) && a && (u += \" \"),\n    i ? (u += \"z\") : n && (u += \"basic\" === o ? \"ZZZ\" : \"ZZ\");\n  let l = Cr(e, u);\n  return s && (l = \"T\" + l), l;\n}\nconst Zr = { month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 },\n  Fr = {\n    weekNumber: 1,\n    weekday: 1,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  },\n  Lr = { ordinal: 1, hour: 0, minute: 0, second: 0, millisecond: 0 },\n  zr = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"],\n  qr = [\n    \"weekYear\",\n    \"weekNumber\",\n    \"weekday\",\n    \"hour\",\n    \"minute\",\n    \"second\",\n    \"millisecond\",\n  ],\n  Ar = [\"year\", \"ordinal\", \"hour\", \"minute\", \"second\", \"millisecond\"];\nfunction jr(e) {\n  var t = {\n    year: \"year\",\n    years: \"year\",\n    month: \"month\",\n    months: \"month\",\n    day: \"day\",\n    days: \"day\",\n    hour: \"hour\",\n    hours: \"hour\",\n    minute: \"minute\",\n    minutes: \"minute\",\n    quarter: \"quarter\",\n    quarters: \"quarter\",\n    second: \"second\",\n    seconds: \"second\",\n    millisecond: \"millisecond\",\n    milliseconds: \"millisecond\",\n    weekday: \"weekday\",\n    weekdays: \"weekday\",\n    weeknumber: \"weekNumber\",\n    weeksnumber: \"weekNumber\",\n    weeknumbers: \"weekNumber\",\n    weekyear: \"weekYear\",\n    weekyears: \"weekYear\",\n    ordinal: \"ordinal\",\n  }[e.toLowerCase()];\n  if (!t) throw new i(e);\n  return t;\n}\nfunction _r(e, t) {\n  const r = xe(t.zone, qe.defaultZone),\n    n = Ye.fromObject(t),\n    s = qe.now();\n  let i, a;\n  if ($(e.year)) i = s;\n  else {\n    for (const o of zr) $(e[o]) && (e[o] = Zr[o]);\n    t = Sr(e) || Or(e);\n    if (t) return Wr.invalid(t);\n    t = r.offset(s);\n    [i, a] = Vr(e, t, r);\n  }\n  return new Wr({ ts: i, zone: r, loc: n, o: a });\n}\nfunction Ur(t, n, s) {\n  const i = !!$(s.round) || s.round,\n    e = (e, t) => {\n      e = H(e, i || s.calendary ? 0 : 2, !0);\n      const r = n.loc.clone(s).relFormatter(s);\n      return r.format(e, t);\n    },\n    r = (e) =>\n      s.calendary\n        ? n.hasSame(t, e)\n          ? 0\n          : n.startOf(e).diff(t.startOf(e), e).get(e)\n        : n.diff(t, e).get(e);\n  if (s.unit) return e(r(s.unit), s.unit);\n  for (const o of s.units) {\n    var a = r(o);\n    if (1 <= Math.abs(a)) return e(a, o);\n  }\n  return e(n < t ? -0 : 0, s.units[s.units.length - 1]);\n}\nfunction Hr(e) {\n  let t = {},\n    r;\n  return (\n    (r =\n      0 < e.length && \"object\" == typeof e[e.length - 1]\n        ? ((t = e[e.length - 1]), Array.from(e).slice(0, e.length - 1))\n        : Array.from(e)),\n    [t, r]\n  );\n}\nclass Wr {\n  constructor(e) {\n    const t = e.zone || qe.defaultZone;\n    let r =\n      e.invalid ||\n      (Number.isNaN(e.ts) ? new ve(\"invalid input\") : null) ||\n      (t.isValid ? null : Mr(t));\n    this.ts = $(e.ts) ? qe.now() : e.ts;\n    let n = null,\n      s = null;\n    var i;\n    r ||\n      (e.old && e.old.ts === this.ts && e.old.zone.equals(t)\n        ? ([n, s] = [e.old.c, e.old.o])\n        : ((i = t.offset(this.ts)),\n          (n = Er(this.ts, i)),\n          (r = Number.isNaN(n.year) ? new ve(\"invalid input\") : null),\n          (n = r ? null : n),\n          (s = r ? null : i))),\n      (this._zone = t),\n      (this.loc = e.loc || Ye.create()),\n      (this.invalid = r),\n      (this.weekData = null),\n      (this.c = n),\n      (this.o = s),\n      (this.isLuxonDateTime = !0);\n  }\n  static now() {\n    return new Wr({});\n  }\n  static local() {\n    var [e, t] = Hr(arguments),\n      [r, n, s, i, a, o, t] = t;\n    return _r(\n      {\n        year: r,\n        month: n,\n        day: s,\n        hour: i,\n        minute: a,\n        second: o,\n        millisecond: t,\n      },\n      e\n    );\n  }\n  static utc() {\n    const [e, t] = Hr(arguments),\n      [r, n, s, i, a, o, u] = t;\n    return (\n      (e.zone = Ve.utcInstance),\n      _r(\n        {\n          year: r,\n          month: n,\n          day: s,\n          hour: i,\n          minute: a,\n          second: o,\n          millisecond: u,\n        },\n        e\n      )\n    );\n  }\n  static fromJSDate(e, t = {}) {\n    var r =\n      \"[object Date]\" === Object.prototype.toString.call(e) ? e.valueOf() : NaN;\n    if (Number.isNaN(r)) return Wr.invalid(\"invalid input\");\n    e = xe(t.zone, qe.defaultZone);\n    return e.isValid\n      ? new Wr({ ts: r, zone: e, loc: Ye.fromObject(t) })\n      : Wr.invalid(Mr(e));\n  }\n  static fromMillis(e, t = {}) {\n    if (Z(e))\n      return e < -864e13 || 864e13 < e\n        ? Wr.invalid(\"Timestamp out of range\")\n        : new Wr({\n            ts: e,\n            zone: xe(t.zone, qe.defaultZone),\n            loc: Ye.fromObject(t),\n          });\n    throw new a(\n      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`\n    );\n  }\n  static fromSeconds(e, t = {}) {\n    if (Z(e))\n      return new Wr({\n        ts: 1e3 * e,\n        zone: xe(t.zone, qe.defaultZone),\n        loc: Ye.fromObject(t),\n      });\n    throw new a(\"fromSeconds requires a numerical input\");\n  }\n  static fromObject(e, t = {}) {\n    e = e || {};\n    const r = xe(t.zone, qe.defaultZone);\n    if (!r.isValid) return Wr.invalid(Mr(r));\n    const n = qe.now(),\n      s = r.offset(n),\n      i = X(e, jr),\n      a = !$(i.ordinal),\n      o = !$(i.year),\n      u = !$(i.month) || !$(i.day),\n      l = o || u,\n      c = i.weekYear || i.weekNumber,\n      h = Ye.fromObject(t);\n    if ((l || a) && c)\n      throw new N(\n        \"Can't mix weekYear/weekNumber units with year/month/day or ordinals\"\n      );\n    if (u && a) throw new N(\"Can't mix ordinal dates with month/day\");\n    var d = c || (i.weekday && !l);\n    let m,\n      f,\n      y = Er(n, s);\n    d\n      ? ((m = qr), (f = Fr), (y = wr(y)))\n      : a\n      ? ((m = Ar), (f = Lr), (y = vr(y)))\n      : ((m = zr), (f = Zr));\n    let g = !1;\n    for (const k of m) $(i[k]) ? (g ? (i[k] = f[k]) : (i[k] = y[k])) : (g = !0);\n    var w,\n      p,\n      v,\n      T,\n      w =\n        (d\n          ? ((p = i),\n            (v = F(p.weekYear)),\n            (t = A(p.weekNumber, 1, Y(p.weekYear))),\n            (T = A(p.weekday, 1, 7)),\n            v\n              ? t\n                ? !T && mr(\"weekday\", p.weekday)\n                : mr(\"week\", p.week)\n              : mr(\"weekYear\", p.weekYear))\n          : a\n          ? ((w = i),\n            (T = F(w.year)),\n            (p = A(w.ordinal, 1, R(w.year))),\n            T ? !p && mr(\"ordinal\", w.ordinal) : mr(\"year\", w.year))\n          : Sr(i)) || Or(i);\n    if (w) return Wr.invalid(w);\n    const S = d ? pr(i) : a ? Tr(i) : i,\n      [O, b] = Vr(S, s, r),\n      M = new Wr({ ts: O, zone: r, o: b, loc: h });\n    return i.weekday && l && e.weekday !== M.weekday\n      ? Wr.invalid(\n          \"mismatched weekday\",\n          `you can't specify both a weekday of ${\n            i.weekday\n          } and a date of ${M.toISO()}`\n        )\n      : M;\n  }\n  static fromISO(e, t = {}) {\n    var [r, n] = Qe(e, [vt, bt], [Tt, Mt], [St, kt], [Ot, Nt]);\n    return xr(r, n, t, \"ISO 8601\", e);\n  }\n  static fromRFC2822(e, t = {}) {\n    var [r, n] = Qe(\n      e\n        .replace(/\\([^)]*\\)|[\\n\\t]/g, \" \")\n        .replace(/(\\s\\s+)/g, \" \")\n        .trim(),\n      [dt, mt]\n    );\n    return xr(r, n, t, \"RFC 2822\", e);\n  }\n  static fromHTTP(e, t = {}) {\n    var [r, e] = Qe(e, [ft, wt], [yt, wt], [gt, pt]);\n    return xr(r, e, t, \"HTTP\", t);\n  }\n  static fromFormat(e, t, r = {}) {\n    if ($(e) || $(t))\n      throw new a(\"fromFormat requires an input string and a format\");\n    var { locale: n = null, numberingSystem: s = null } = r,\n      [i, n, s] = (function (e, t, r) {\n        var { result: e, zone: t, invalidReason: r } = cr(e, t, r);\n        return [e, t, r];\n      })(Ye.fromOpts({ locale: n, numberingSystem: s, defaultToEN: !0 }), e, t);\n    return s ? Wr.invalid(s) : xr(i, n, r, `format ${t}`, e);\n  }\n  static fromString(e, t, r = {}) {\n    return Wr.fromFormat(e, t, r);\n  }\n  static fromSQL(e, t = {}) {\n    var [r, n] = Qe(e, [Et, It], [Vt, xt]);\n    return xr(r, n, t, \"SQL\", e);\n  }\n  static invalid(e, t = null) {\n    if (!e) throw new a(\"need to specify a reason the DateTime is invalid\");\n    t = e instanceof ve ? e : new ve(e, t);\n    if (qe.throwOnInvalid) throw new r(t);\n    return new Wr({ invalid: t });\n  }\n  static isDateTime(e) {\n    return (e && e.isLuxonDateTime) || !1;\n  }\n  get(e) {\n    return this[e];\n  }\n  get isValid() {\n    return null === this.invalid;\n  }\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n  get locale() {\n    return this.isValid ? this.loc.locale : null;\n  }\n  get numberingSystem() {\n    return this.isValid ? this.loc.numberingSystem : null;\n  }\n  get outputCalendar() {\n    return this.isValid ? this.loc.outputCalendar : null;\n  }\n  get zone() {\n    return this._zone;\n  }\n  get zoneName() {\n    return this.isValid ? this.zone.name : null;\n  }\n  get year() {\n    return this.isValid ? this.c.year : NaN;\n  }\n  get quarter() {\n    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;\n  }\n  get month() {\n    return this.isValid ? this.c.month : NaN;\n  }\n  get day() {\n    return this.isValid ? this.c.day : NaN;\n  }\n  get hour() {\n    return this.isValid ? this.c.hour : NaN;\n  }\n  get minute() {\n    return this.isValid ? this.c.minute : NaN;\n  }\n  get second() {\n    return this.isValid ? this.c.second : NaN;\n  }\n  get millisecond() {\n    return this.isValid ? this.c.millisecond : NaN;\n  }\n  get weekYear() {\n    return this.isValid ? kr(this).weekYear : NaN;\n  }\n  get weekNumber() {\n    return this.isValid ? kr(this).weekNumber : NaN;\n  }\n  get weekday() {\n    return this.isValid ? kr(this).weekday : NaN;\n  }\n  get ordinal() {\n    return this.isValid ? vr(this.c).ordinal : NaN;\n  }\n  get monthShort() {\n    return this.isValid\n      ? Rt.months(\"short\", { locObj: this.loc })[this.month - 1]\n      : null;\n  }\n  get monthLong() {\n    return this.isValid\n      ? Rt.months(\"long\", { locObj: this.loc })[this.month - 1]\n      : null;\n  }\n  get weekdayShort() {\n    return this.isValid\n      ? Rt.weekdays(\"short\", { locObj: this.loc })[this.weekday - 1]\n      : null;\n  }\n  get weekdayLong() {\n    return this.isValid\n      ? Rt.weekdays(\"long\", { locObj: this.loc })[this.weekday - 1]\n      : null;\n  }\n  get offset() {\n    return this.isValid ? +this.o : NaN;\n  }\n  get offsetNameShort() {\n    return this.isValid\n      ? this.zone.offsetName(this.ts, { format: \"short\", locale: this.locale })\n      : null;\n  }\n  get offsetNameLong() {\n    return this.isValid\n      ? this.zone.offsetName(this.ts, { format: \"long\", locale: this.locale })\n      : null;\n  }\n  get isOffsetFixed() {\n    return this.isValid ? this.zone.isUniversal : null;\n  }\n  get isInDST() {\n    return (\n      !this.isOffsetFixed &&\n      (this.offset > this.set({ month: 1 }).offset ||\n        this.offset > this.set({ month: 5 }).offset)\n    );\n  }\n  get isInLeapYear() {\n    return W(this.year);\n  }\n  get daysInMonth() {\n    return P(this.year, this.month);\n  }\n  get daysInYear() {\n    return this.isValid ? R(this.year) : NaN;\n  }\n  get weeksInWeekYear() {\n    return this.isValid ? Y(this.weekYear) : NaN;\n  }\n  resolvedLocaleOptions(e = {}) {\n    var {\n      locale: t,\n      numberingSystem: r,\n      calendar: e,\n    } = pe.create(this.loc.clone(e), e).resolvedOptions(this);\n    return { locale: t, numberingSystem: r, outputCalendar: e };\n  }\n  toUTC(e = 0, t = {}) {\n    return this.setZone(Ve.instance(e), t);\n  }\n  toLocal() {\n    return this.setZone(qe.defaultZone);\n  }\n  setZone(t, { keepLocalTime: r = !1, keepCalendarTime: n = !1 } = {}) {\n    if ((t = xe(t, qe.defaultZone)).equals(this.zone)) return this;\n    if (t.isValid) {\n      let e = this.ts;\n      return (\n        (r || n) &&\n          ((r = t.offset(this.ts)), (n = this.toObject()), ([e] = Vr(n, r, t))),\n        Nr(this, { ts: e, zone: t })\n      );\n    }\n    return Wr.invalid(Mr(t));\n  }\n  reconfigure({ locale: e, numberingSystem: t, outputCalendar: r } = {}) {\n    r = this.loc.clone({ locale: e, numberingSystem: t, outputCalendar: r });\n    return Nr(this, { loc: r });\n  }\n  setLocale(e) {\n    return this.reconfigure({ locale: e });\n  }\n  set(e) {\n    if (!this.isValid) return this;\n    var t = X(e, jr),\n      r = !$(t.weekYear) || !$(t.weekNumber) || !$(t.weekday),\n      n = !$(t.ordinal),\n      s = !$(t.year),\n      i = !$(t.month) || !$(t.day),\n      e = t.weekYear || t.weekNumber;\n    if ((s || i || n) && e)\n      throw new N(\n        \"Can't mix weekYear/weekNumber units with year/month/day or ordinals\"\n      );\n    if (i && n) throw new N(\"Can't mix ordinal dates with month/day\");\n    let a;\n    r\n      ? (a = pr({ ...wr(this.c), ...t }))\n      : $(t.ordinal)\n      ? ((a = { ...this.toObject(), ...t }),\n        $(t.day) && (a.day = Math.min(P(a.year, a.month), a.day)))\n      : (a = Tr({ ...vr(this.c), ...t }));\n    var [r, t] = Vr(a, this.o, this.zone);\n    return Nr(this, { ts: r, o: t });\n  }\n  plus(e) {\n    return this.isValid ? Nr(this, Ir(this, Ut(e))) : this;\n  }\n  minus(e) {\n    return this.isValid ? Nr(this, Ir(this, Ut(e).negate())) : this;\n  }\n  startOf(e) {\n    if (!this.isValid) return this;\n    const t = {},\n      r = _t.normalizeUnit(e);\n    switch (r) {\n      case \"years\":\n        t.month = 1;\n      case \"quarters\":\n      case \"months\":\n        t.day = 1;\n      case \"weeks\":\n      case \"days\":\n        t.hour = 0;\n      case \"hours\":\n        t.minute = 0;\n      case \"minutes\":\n        t.second = 0;\n      case \"seconds\":\n        t.millisecond = 0;\n    }\n    return (\n      \"weeks\" === r && (t.weekday = 1),\n      \"quarters\" === r &&\n        ((e = Math.ceil(this.month / 3)), (t.month = 3 * (e - 1) + 1)),\n      this.set(t)\n    );\n  }\n  endOf(e) {\n    return this.isValid\n      ? this.plus({ [e]: 1 })\n          .startOf(e)\n          .minus(1)\n      : this;\n  }\n  toFormat(e, t = {}) {\n    return this.isValid\n      ? pe.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this, e)\n      : br;\n  }\n  toLocaleString(e = c, t = {}) {\n    return this.isValid\n      ? pe.create(this.loc.clone(t), e).formatDateTime(this)\n      : br;\n  }\n  toLocaleParts(e = {}) {\n    return this.isValid\n      ? pe.create(this.loc.clone(e), e).formatDateTimeParts(this)\n      : [];\n  }\n  toISO(e = {}) {\n    return this.isValid ? `${this.toISODate(e)}T${this.toISOTime(e)}` : null;\n  }\n  toISODate({ format: e = \"extended\" } = {}) {\n    let t = \"basic\" === e ? \"yyyyMMdd\" : \"yyyy-MM-dd\";\n    return 9999 < this.year && (t = \"+\" + t), Cr(this, t);\n  }\n  toISOWeekDate() {\n    return Cr(this, \"kkkk-'W'WW-c\");\n  }\n  toISOTime({\n    suppressMilliseconds: e = !1,\n    suppressSeconds: t = !1,\n    includeOffset: r = !0,\n    includePrefix: n = !1,\n    format: s = \"extended\",\n  } = {}) {\n    return $r(this, {\n      suppressSeconds: t,\n      suppressMilliseconds: e,\n      includeOffset: r,\n      includePrefix: n,\n      format: s,\n    });\n  }\n  toRFC2822() {\n    return Cr(this, \"EEE, dd LLL yyyy HH:mm:ss ZZZ\", !1);\n  }\n  toHTTP() {\n    return Cr(this.toUTC(), \"EEE, dd LLL yyyy HH:mm:ss 'GMT'\");\n  }\n  toSQLDate() {\n    return Cr(this, \"yyyy-MM-dd\");\n  }\n  toSQLTime({ includeOffset: e = !0, includeZone: t = !1 } = {}) {\n    return $r(this, { includeOffset: e, includeZone: t, spaceZone: !0 });\n  }\n  toSQL(e = {}) {\n    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;\n  }\n  toString() {\n    return this.isValid ? this.toISO() : br;\n  }\n  valueOf() {\n    return this.toMillis();\n  }\n  toMillis() {\n    return this.isValid ? this.ts : NaN;\n  }\n  toSeconds() {\n    return this.isValid ? this.ts / 1e3 : NaN;\n  }\n  toJSON() {\n    return this.toISO();\n  }\n  toBSON() {\n    return this.toJSDate();\n  }\n  toObject(e = {}) {\n    if (!this.isValid) return {};\n    const t = { ...this.c };\n    return (\n      e.includeConfig &&\n        ((t.outputCalendar = this.outputCalendar),\n        (t.numberingSystem = this.loc.numberingSystem),\n        (t.locale = this.loc.locale)),\n      t\n    );\n  }\n  toJSDate() {\n    return new Date(this.isValid ? this.ts : NaN);\n  }\n  diff(e, t = \"milliseconds\", r = {}) {\n    if (!this.isValid || !e.isValid)\n      return _t.invalid(\"created by diffing an invalid DateTime\");\n    r = { locale: this.locale, numberingSystem: this.numberingSystem, ...r };\n    const n = ((t = t), (Array.isArray(t) ? t : [t]).map(_t.normalizeUnit)),\n      s = e.valueOf() > this.valueOf(),\n      i = s ? this : e,\n      a = s ? e : this,\n      o = Jt(i, a, n, r);\n    return s ? o.negate() : o;\n  }\n  diffNow(e = \"milliseconds\", t = {}) {\n    return this.diff(Wr.now(), e, t);\n  }\n  until(e) {\n    return this.isValid ? Wt.fromDateTimes(this, e) : this;\n  }\n  hasSame(e, t) {\n    if (!this.isValid) return !1;\n    var r = e.valueOf();\n    const n = this.setZone(e.zone, { keepLocalTime: !0 });\n    return n.startOf(t) <= r && r <= n.endOf(t);\n  }\n  equals(e) {\n    return (\n      this.isValid &&\n      e.isValid &&\n      this.valueOf() === e.valueOf() &&\n      this.zone.equals(e.zone) &&\n      this.loc.equals(e.loc)\n    );\n  }\n  toRelative(e = {}) {\n    if (!this.isValid) return null;\n    var t = e.base || Wr.fromObject({}, { zone: this.zone }),\n      r = e.padding ? (this < t ? -e.padding : e.padding) : 0;\n    let n = [\"years\", \"months\", \"days\", \"hours\", \"minutes\", \"seconds\"],\n      s = e.unit;\n    return (\n      Array.isArray(e.unit) && ((n = e.unit), (s = void 0)),\n      Ur(t, this.plus(r), { ...e, numeric: \"always\", units: n, unit: s })\n    );\n  }\n  toRelativeCalendar(e = {}) {\n    return this.isValid\n      ? Ur(e.base || Wr.fromObject({}, { zone: this.zone }), this, {\n          ...e,\n          numeric: \"auto\",\n          units: [\"years\", \"months\", \"days\"],\n          calendary: !0,\n        })\n      : null;\n  }\n  static min(...e) {\n    if (!e.every(Wr.isDateTime))\n      throw new a(\"min requires all arguments be DateTimes\");\n    return z(e, (e) => e.valueOf(), Math.min);\n  }\n  static max(...e) {\n    if (!e.every(Wr.isDateTime))\n      throw new a(\"max requires all arguments be DateTimes\");\n    return z(e, (e) => e.valueOf(), Math.max);\n  }\n  static fromFormatExplain(e, t, r = {}) {\n    var { locale: n = null, numberingSystem: r = null } = r;\n    return cr(\n      Ye.fromOpts({ locale: n, numberingSystem: r, defaultToEN: !0 }),\n      e,\n      t\n    );\n  }\n  static fromStringExplain(e, t, r = {}) {\n    return Wr.fromFormatExplain(e, t, r);\n  }\n  static get DATE_SHORT() {\n    return c;\n  }\n  static get DATE_MED() {\n    return h;\n  }\n  static get DATE_MED_WITH_WEEKDAY() {\n    return d;\n  }\n  static get DATE_FULL() {\n    return m;\n  }\n  static get DATE_HUGE() {\n    return f;\n  }\n  static get TIME_SIMPLE() {\n    return y;\n  }\n  static get TIME_WITH_SECONDS() {\n    return g;\n  }\n  static get TIME_WITH_SHORT_OFFSET() {\n    return w;\n  }\n  static get TIME_WITH_LONG_OFFSET() {\n    return p;\n  }\n  static get TIME_24_SIMPLE() {\n    return v;\n  }\n  static get TIME_24_WITH_SECONDS() {\n    return T;\n  }\n  static get TIME_24_WITH_SHORT_OFFSET() {\n    return S;\n  }\n  static get TIME_24_WITH_LONG_OFFSET() {\n    return O;\n  }\n  static get DATETIME_SHORT() {\n    return b;\n  }\n  static get DATETIME_SHORT_WITH_SECONDS() {\n    return M;\n  }\n  static get DATETIME_MED() {\n    return k;\n  }\n  static get DATETIME_MED_WITH_SECONDS() {\n    return D;\n  }\n  static get DATETIME_MED_WITH_WEEKDAY() {\n    return E;\n  }\n  static get DATETIME_FULL() {\n    return V;\n  }\n  static get DATETIME_FULL_WITH_SECONDS() {\n    return I;\n  }\n  static get DATETIME_HUGE() {\n    return x;\n  }\n  static get DATETIME_HUGE_WITH_SECONDS() {\n    return C;\n  }\n}\nfunction Rr(e) {\n  if (Wr.isDateTime(e)) return e;\n  if (e && e.valueOf && Z(e.valueOf())) return Wr.fromJSDate(e);\n  if (e && \"object\" == typeof e) return Wr.fromObject(e);\n  throw new a(`Unknown datetime argument: ${e}, of type ${typeof e}`);\n}\nXe = \"2.0.2\";\n\n\n\n//# sourceURL=webpack://intro-webpack/./src/js/luxon.js?");

/***/ }),

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ \"./src/js/timer.js\");\n/* harmony import */ var _dates_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dates.js */ \"./src/js/dates.js\");\n/* harmony import */ var _style_style_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../style/style.css */ \"./src/style/style.css\");\n\n\n\nconst dateCalcForm = document.getElementById(\"datecalc\");\n\ndateCalcForm.addEventListener(\"submit\", _dates_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n\n//# sourceURL=webpack://intro-webpack/./src/js/main.js?");

/***/ }),

/***/ "./src/js/sound.js":
/*!*************************!*\
  !*** ./src/js/sound.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"url\": () => (/* binding */ url),\n/* harmony export */   \"s1\": () => (/* binding */ s1)\n/* harmony export */ });\n/* harmony import */ var _howler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./howler.js */ \"./src/js/howler.js\");\n/* harmony import */ var _howler_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_howler_js__WEBPACK_IMPORTED_MODULE_0__);\n\nlet url =\n  \"https://www.dropbox.com/s/q5g5h3d2730f5r0/youofthedark.ogg?raw=1\";\nlet s1 = new Howl({\n  src: [url],\n});\n\n\n//# sourceURL=webpack://intro-webpack/./src/js/sound.js?");

/***/ }),

/***/ "./src/js/timer.js":
/*!*************************!*\
  !*** ./src/js/timer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createInterval\": () => (/* binding */ createInterval),\n/* harmony export */   \"resetTime\": () => (/* binding */ resetTime)\n/* harmony export */ });\n/* harmony import */ var _sound_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sound.js */ \"./src/js/sound.js\");\n\n\nlet sec = 0;\nlet min = 0;\nlet hour = 0;\nconst start = document.getElementById(\"start\");\nconst reset = document.getElementById(\"reset\");\nconst stop = document.getElementById(\"stop\");\n\nlet closeSeconds;\nlet closeMinutes;\nlet closeHours;\n\nconst resetTime = () => {\n  closeSeconds();\n  closeMinutes();\n  closeHours();\n  sec = 0;\n  min = 0;\n  hour = 0;\n  _sound_js__WEBPACK_IMPORTED_MODULE_0__.s1.stop();\n  const xs = document.querySelectorAll(\".t\");\n  xs.forEach((time, i) => {\n    if (time.dataset.time === \"hour\" || time.dataset.time === \"min\") {\n      time.innerHTML = \"00:\";\n    } else {\n      time.innerHTML = \"00\";\n    }\n  });\n  document.getElementById(\"time\").classList.remove(\"pulse\");\n  reset.setAttribute(\"disabled\", true);\n  stop.setAttribute(\"disabled\", true);\n};\n\nconst createInterval = (ms) => (fn) => {\n  let id = setInterval(fn, ms);\n  return () => clearInterval(id);\n};\n\nstart.addEventListener(\"click\", () => {\n  document.getElementById(\"time\").classList.remove(\"pulse\");\n  //start sound\n  _sound_js__WEBPACK_IMPORTED_MODULE_0__.s1.play();\n  reset.removeAttribute(\"disabled\");\n  stop.removeAttribute(\"disabled\");\n  closeSeconds = createInterval(1000)(() => {\n    sec++;\n    if (sec >= 60) {\n      sec = 0;\n    }\n    let pre = `0${sec}`;\n    document.getElementById(\"sec\").innerText = sec < 10 ? pre : sec;\n  });\n  closeMinutes = createInterval(60000)(() => {\n    min++;\n    let pre = `0${min}:`;\n    document.getElementById(\"min\").innerText = min < 10 ? pre : min + \":\";\n  });\n\n  closeHours = createInterval(3_600_000)(() => {\n    hour++;\n    let pre = `0${hour}:`;\n    document.getElementById(\"hour\").innerText = hour < 10 ? pre : hour + \":\";\n  });\n});\nstop.addEventListener(\"click\", () => {\n  stop.setAttribute(\"disabled\", true);\n  //start sound\n  _sound_js__WEBPACK_IMPORTED_MODULE_0__.s1.stop();\n  document.getElementById(\"time\").classList.add(\"pulse\");\n  closeSeconds();\n  closeMinutes();\n  closeHours();\n});\nreset.addEventListener(\"click\", resetTime);\n\nreset.setAttribute(\"disabled\", true);\nstop.setAttribute(\"disabled\", true);\n\n\n\n\n//# sourceURL=webpack://intro-webpack/./src/js/timer.js?");

/***/ }),

/***/ "./src/js/utils.js":
/*!*************************!*\
  !*** ./src/js/utils.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"formatError\": () => (/* binding */ formatError)\n/* harmony export */ });\nconst formatError = (text) => `\n<span style=\"color: red;\">\n    ${text}\n</span>\n`;\n\n//# sourceURL=webpack://intro-webpack/./src/js/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/main.js");
/******/ 	
/******/ })()
;